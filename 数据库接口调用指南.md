# 数据库接口调用指南

本文档详细说明如何调用项目中已实现的数据库接口进行 CRUD（增删改查）操作。

## 1. 概览

目前项目中包含 4 张主要数据表，其中 3 张表已封装了标准的 Service 服务类，1 张表目前通过管理器或直接调用进行操作。

| 表名 | 模型类 | Service 服务类 | 状态 |
|------|--------|----------------|------|
| `tb_fruitinfo` | `FruitInfo` | `FruitInfoService` | ✅ 已就绪 |
| `tb_gradeinfo` | `GradeInfo` | `GradeInfoService` | ✅ 已就绪 |
| `tb_exportinfo` | `ExportInfo` | `ExportInfoService` | ✅ 已就绪 |
| `processing_history` | `ProcessingHistory` | - | ⚠️ 无专用Service (见下文) |

---

## 2. 标准 Service 调用方式

对于已实现 Service 的表（水果、等级、导出信息），请统一使用 Service 类提供的静态方法。这些方法内部已经封装了 `DatabaseQueueManager`，确保了线程安全和异步执行。

### 2.1 引入模块

在使用前，请确保导入相应的 Service 类和数据模型：

```typescript
import { FruitInfoService } from '../services/FruitInfoService';
import { GradeInfoService } from '../services/GradeInfoService';
import { ExportInfoService } from '../services/ExportInfoService';
// 导入模型用于类型提示
import { FruitInfo } from '../database/models/FruitInfo';
```

### 2.2 插入数据 (Create)

**单条插入：**

```typescript
// 示例：保存水果信息
const fruitData: Partial<FruitInfo> = {
  FruitName: 'Apple',
  BatchWeight: 100.5,
  StartTime: '2023-10-01 10:00:00',
  SortType: 1
};

try {
  // 方式1：不传 context (推荐，内部自动使用全局 Context)
  const id = await FruitInfoService.save(fruitData);
  console.info('保存成功，ID:', id);
  
  // 方式2：显式传递 context (兼容旧代码)
  // const id = await FruitInfoService.save(fruitData, context);
} catch (error) {
  console.error('保存失败:', error);
}
```

**批量插入：**

```typescript
const list: Partial<FruitInfo>[] = [
  { FruitName: 'Apple', BatchWeight: 100 },
  { FruitName: 'Pear', BatchWeight: 200 }
];

const count = await FruitInfoService.batchSave(list);
console.info(`成功插入 ${count} 条数据`);
```

### 2.3 查询数据 (Read)

**查询所有：**

```typescript
const list = await FruitInfoService.queryAll();
```

**分页查询：**

```typescript
const page = 1;
const size = 20;
const pageList = await FruitInfoService.queryPage(page, size);
```

**特定条件查询 (ExportInfoService 特有)：**

```typescript
// 根据客户ID查询
const exports = await ExportInfoService.queryByCustomerId(1001);
```

### 2.4 更新数据 (Update)

```typescript
const id = 1;
const updateData: Partial<FruitInfo> = {
  BatchWeight: 150.0,
  CompletedState: 'Finished'
};

const affected = await FruitInfoService.update(id, updateData);
console.info(`更新了 ${affected} 行`);
```

### 2.5 删除数据 (Delete)

```typescript
const id = 1;
const affected = await FruitInfoService.delete(id);
console.info(`删除了 ${affected} 行`);
```

---

## 3. ProcessingHistory 表的操作

`ProcessingHistory` 表目前没有独立的 `ProcessingHistoryService` 类。它目前主要在 `HistoryTableManager` (UI层) 和 `ProcessingApiHandler` (API层) 中被使用。

如果你需要在业务逻辑中操作此表，建议使用以下两种方式之一：

### 方式一：直接使用 DatabaseQueueManager (推荐)

你可以直接使用底层的队列管理器进行操作，这与 Service 内部的实现方式一致。

```typescript
import { DatabaseQueueManager } from '../utils/network/database/dispatch/DatabaseQueueManager';
import { ProcessingHistory } from '../database/models/ProcessingHistory';
import { relationalStore } from '@kit.ArkData';

// 1. 插入
const values: relationalStore.ValuesBucket = {
  customer_name: 'Client A',
  fruit_name: 'Apple',
  start_time: '2023-10-01 10:00:00',
  status: '进行中'
};
const id = await DatabaseQueueManager.insert(context, values, ProcessingHistory);

// 2. 查询所有
const list = await DatabaseQueueManager.queryAll<ProcessingHistory>(context, ProcessingHistory);

// 3. 自定义条件查询
const results = await DatabaseQueueManager.queryByCondition<ProcessingHistory>(
  context,
  ProcessingHistory,
  "status = ?",
  ['已完成']
);
```

### 方式二：创建 ProcessingHistoryService (最佳实践)

为了保持代码风格统一，建议参照 `FruitInfoService.ets` 创建一个 `ProcessingHistoryService.ets`。

**建议结构：**
1. 复制 `FruitInfoService.ets`。
2. 将所有 `FruitInfo` 替换为 `ProcessingHistory`。
3. 修改 `toValuesBucket` 方法以匹配 `ProcessingHistory` 的字段（如 `CustomerName`, `FarmName`, `Status` 等）。

---

## 4. 注意事项

1.  **Context 传递**：所有数据库操作都需要传入 UIAbility 的 `Context`。
2.  **异步操作**：所有接口均为 `async/await` 异步方法，请务必处理 `Promise`。
3.  **错误处理**：建议使用 `try-catch` 捕获可能的数据库异常。
4.  **字段映射**：Service 层会自动处理驼峰命名（如 `FruitName`）到数据库下划线命名（如 `fruit_name`）的转换，调用者只需关注模型对象的属性即可。
