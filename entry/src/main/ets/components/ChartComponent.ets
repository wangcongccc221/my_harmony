// æ•°æ®æ¥å£å®šä¹‰
import { BaseComponentHelper } from './common/BaseComponent'
import { ExtendedOmniThemeStyle } from '../utils/theme/OmniThemeManager'
export interface ChartData {
  time: string;
  value: number;
}

// å›¾è¡¨ç»„ä»¶å‚æ•°æ¥å£
export interface ChartComponentParams {
  dataCount?: number; // æ•°æ®ç‚¹æ•°é‡ï¼Œé»˜è®¤50
  startHour?: number; // å¼€å§‹å°æ—¶ï¼Œé»˜è®¤15
  startMinute?: number; // å¼€å§‹åˆ†é’Ÿï¼Œé»˜è®¤0
  chartHeight?: number; // å›¾è¡¨é«˜åº¦ï¼Œé»˜è®¤300
  barWidth?: number; // æŸ±å­å®½åº¦ï¼Œé»˜è®¤20
  barSpacing?: number; // æŸ±å­é—´è·ï¼Œé»˜è®¤50
  showScrollBar?: boolean; // æ˜¯å¦æ˜¾ç¤ºæ»šåŠ¨æ¡ï¼Œé»˜è®¤false
  onDataClick?: (data: ChartData, event: ClickEvent) => void; // æ•°æ®ç‚¹å‡»å›è°ƒ
  axisFontSizePx?: number; // Yè½´åˆ»åº¦å­—ä½“å¤§å°
  labelFontSizePx?: number; // Xè½´æ ‡ç­¾å­—ä½“å¤§å°
  axisFontBold?: boolean; // Yè½´æ–‡å­—åŠ ç²—
  labelFontBold?: boolean; // Xè½´æ–‡å­—åŠ ç²—
}

@Component
export struct ChartComponent {
  // ä¸»é¢˜æ¥å…¥
  private baseComponentHelper = new BaseComponentHelper()
  @Consume providedTheme: ExtendedOmniThemeStyle
  @State chartData: ChartData[] = [];
  @State dataCount: number = 50;
  @State startHour: number = 15;
  @State startMinute: number = 0;
  @State chartHeight: number = 300;
  @State barWidth: number = 20;
  @State barSpacing: number = 50;
  @State showScrollBar: boolean = false;
  @State axisFontSizePx: number = 12;
  @State labelFontSizePx: number = 16;
  @State axisFontBold: boolean = false;
  @State labelFontBold: boolean = false;
  @State tooltipVisible: boolean = false;
  @State tooltipText: string = '';
  @State tooltipX: number = 0;
  @State tooltipY: number = 0;
  @Prop params: ChartComponentParams = {};
  scroller: Scroller = new Scroller();
  
  // å®æ—¶æ•°æ®æ›´æ–°ç›¸å…³
  private timerId?: number;
  private currentValue: number = 50; // å½“å‰æ•°å€¼
  @State private followLatest: boolean = true; // æ˜¯å¦è‡ªåŠ¨è·Ÿéšæœ€æ–°
  @State private lastScrollX: number = 0; // æœ€è¿‘ä¸€æ¬¡æ»šåŠ¨ä½ç½®
  private currentTimeIndex: number = 0; // å½“å‰æ—¶é—´ç´¢å¼•

  // ç”Ÿæˆæ—¶é—´æ ‡ç­¾
  generateTimeLabels(count: number): string[] {
    const labels: string[] = [];
    
    for (let i = 0; i < count; i++) {
      const hour = this.startHour + Math.floor((this.startMinute + i) / 60);
      const minute = (this.startMinute + i) % 60;
      
      const hourStr = hour.toString().padStart(2, '0');
      const minuteStr = minute.toString().padStart(2, '0');
      
      labels.push(`${hourStr}:${minuteStr}`);
    }
    
    return labels;
  }

  // ç”Ÿæˆéšæœºæ•°æ®
  generateData(): void {
    const timeLabels = this.generateTimeLabels(this.dataCount);
    this.chartData = timeLabels.map((time: string, index: number): ChartData => ({
      time: time,
      value: Math.floor(Math.random() * 90) + 10 // 10-100ä¹‹é—´çš„éšæœºæ•°
    }));
  }

  // ç”Ÿæˆæ–°çš„æ—¶é—´æ ‡ç­¾ï¼ˆåŸºäºåˆå§‹æ—¶é—´ç»§ç»­ï¼‰
  private generateNewTimeLabel(): string {
    // åŸºäºåˆå§‹æ—¶é—´ç»§ç»­ï¼Œæ¯åˆ†é’Ÿä¸€ä¸ªæ•°æ®ç‚¹
    const totalMinutes = this.startMinute + this.currentTimeIndex;
    const hour = this.startHour + Math.floor(totalMinutes / 60);
    const minute = totalMinutes % 60;
    
    const hourStr = hour.toString().padStart(2, '0');
    const minuteStr = minute.toString().padStart(2, '0');
    
    this.currentTimeIndex++;
    return `${hourStr}:${minuteStr}`;
  }

  // ç”Ÿæˆæ–°çš„æ•°å€¼ï¼ˆéšæœºæ¸¸èµ°ï¼‰
  private generateNewValue(): number {
    const step = (Math.random() * 10) - 5; // -5 ~ +5
    this.currentValue = Math.max(10, Math.min(100, Math.round(this.currentValue + step)));
    return this.currentValue;
  }

  // å¯åŠ¨å®æ—¶æ•°æ®æ›´æ–°
  private startRealTimeUpdate(): void {
    if (this.timerId) return;
    
    this.timerId = setInterval(() => {
      const newTime = this.generateNewTimeLabel();
      const newValue = this.generateNewValue();
      
      // æ·»åŠ æ–°æ•°æ®ç‚¹ï¼›å½“æ•°é‡è¶…è¿‡60æ—¶ï¼Œæ¸…ç©ºå¹¶é‡æ–°å¼€å§‹æ˜¾ç¤º
      this.chartData = [...this.chartData, { time: newTime, value: newValue }];
      const maxDataPoints: number = 60;
      if (this.chartData.length > maxDataPoints) {
        console.log(`ğŸ”„ æ•°æ®é‡è¶…è¿‡${maxDataPoints}ï¼Œè‡ªåŠ¨æ¸…ç©ºé‡æ–°å¼€å§‹...`)
        this.chartData = []
        this.currentTimeIndex = 0
        console.log(`âœ… æ•°æ®å·²æ¸…ç©ºï¼Œé‡æ–°å¼€å§‹è¿½è¸ª`)
      }
      
      // ä»…åœ¨è·Ÿéšæœ€æ–°æ—¶ï¼Œè‡ªåŠ¨æ»šåŠ¨åˆ°æœ«å°¾
      if (this.followLatest) {
        setTimeout(() => {
          this.scroller.scrollTo({ xOffset: this.chartData.length * (this.barWidth + this.barSpacing), yOffset: 0 });
        }, 100);
      }
      
    }, 1000) as number;
  }

  // åœæ­¢å®æ—¶æ•°æ®æ›´æ–°
  private stopRealTimeUpdate(): void {
    if (this.timerId) {
      clearInterval(this.timerId);
      this.timerId = undefined;
    }
  }

  // æ˜¾ç¤ºæç¤ºæ¡†
  showTooltip(data: ChartData, event: ClickEvent): void {
    this.tooltipText = `æ—¶é—´: ${data.time}\næ•°å€¼: ${data.value}`;
    this.tooltipX = event.x + 10;
    this.tooltipY = event.y - 40;
    this.tooltipVisible = true;
  }

  // éšè—æç¤ºæ¡†
  hideTooltip(): void {
    this.tooltipVisible = false;
  }

  // å¤„ç†æ•°æ®ç‚¹å‡»
  handleDataClick(data: ChartData, event: ClickEvent): void {
    if (this.params.onDataClick) {
      this.params.onDataClick(data, event);
    } else {
      this.showTooltip(data, event);
    }
  }

  aboutToAppear(): void {
    // åº”ç”¨å‚æ•°
    this.dataCount = this.params.dataCount || 50;
    this.startHour = this.params.startHour || 15;
    this.startMinute = this.params.startMinute || 0;
    this.chartHeight = this.params.chartHeight || 300;
    this.barWidth = this.params.barWidth || 20;
    this.barSpacing = this.params.barSpacing || 50;
    this.showScrollBar = this.params.showScrollBar || false;
    this.axisFontSizePx = this.params.axisFontSizePx || 12;
    this.labelFontSizePx = this.params.labelFontSizePx || 16;
    this.axisFontBold = !!this.params.axisFontBold;
    this.labelFontBold = !!this.params.labelFontBold;
    
    // åˆå§‹åŒ–æ—¶é—´ç´¢å¼•ï¼ˆä»åˆå§‹æ•°æ®é‡å¼€å§‹ï¼‰
    this.currentTimeIndex = this.dataCount;
    
    // åˆå§‹åŒ–æ•°æ®
    this.generateData();
    
    // å¯åŠ¨å®æ—¶æ•°æ®æ›´æ–°
    this.startRealTimeUpdate();
  }

  aboutToDisappear(): void {
    // åœæ­¢å®æ—¶æ•°æ®æ›´æ–°
    this.stopRealTimeUpdate();
  }

  getCurrentTheme(): ExtendedOmniThemeStyle {
    return this.baseComponentHelper.getCurrentTheme(this.providedTheme)
  }

  build() {
    Stack() {
      Column() {
        // å›¾è¡¨å®¹å™¨
        Column() {
          // å›¾è¡¨ä¸»ä½“åŒºåŸŸ
          Row() {
            // Yè½´æ ‡ç­¾
            Column() {
              ForEach([100, 80, 60, 40, 20, 0], (value: number) => {
                Text(value.toString())
                  .fontSize(this.axisFontSizePx)
                  .fontWeight(this.axisFontBold ? FontWeight.Bold : FontWeight.Regular)
                  .fontColor(this.getCurrentTheme().subTextColor)
                  .width(40)
                  .textAlign(TextAlign.End)
                  .margin({ right: 5 })
              })
            }
            .width(45)
            .height(this.chartHeight)
            .justifyContent(FlexAlign.SpaceBetween)
            .padding({ top: 10, bottom: 10 })
            .border({ width: 1, color: this.getCurrentTheme().borderColor })

            // å›¾è¡¨åŒºåŸŸï¼ˆå¯æ»šåŠ¨ï¼‰
            Scroll(this.scroller) {
              Row() {
                ForEach(this.chartData, (data: ChartData, index: number) => {
                  Column() {
                    // æ•°å€¼æ ‡ç­¾ï¼ˆåœ¨æŸ±å­é¡¶éƒ¨ï¼‰
                    Text(data.value.toString())
                      .fontSize(16)
                      .fontColor(this.getCurrentTheme().textColor)
                      .fontWeight(FontWeight.Bold)
                      .margin({ bottom: 2 })
                      .textAlign(TextAlign.Center)

                    // æŸ±å­
                    Column()
                      .width(this.barWidth) // ä½¿ç”¨å¯é…ç½®çš„æŸ±å­å®½åº¦
                      .height(data.value * 2.5) // æ ¹æ®æ•°å€¼è®¾ç½®é«˜åº¦
                      .backgroundColor(this.getCurrentTheme().chartLineColor ?? this.getCurrentTheme().primary)
                      .borderRadius({ topLeft: 3, topRight: 3 })
                      .onClick((event: ClickEvent) => {
                        this.handleDataClick(data, event);
                      })
                      .onTouch((event: TouchEvent) => {
                        if (event.type === TouchType.Down) {
                          const clickEvent: ClickEvent = {
                            x: event.touches[0].x,
                            y: event.touches[0].y
                          } as ClickEvent;
                          this.handleDataClick(data, clickEvent);
                        } else if (event.type === TouchType.Up) {
                          this.hideTooltip();
                        }
                      })

                    // æ—¶é—´æ ‡ç­¾
                    Text(data.time)
                      .fontSize(this.labelFontSizePx)
                      .fontWeight(this.labelFontBold ? FontWeight.Bold : FontWeight.Regular)
                      .fontColor(this.getCurrentTheme().subTextColor)
                      .margin({ top: 5 })
                      .textAlign(TextAlign.Center)
                  }
                  .margin({ left: this.barSpacing / 2, right: this.barSpacing / 2 }) // ä½¿ç”¨å¯é…ç½®çš„é—´è·
                  .alignItems(HorizontalAlign.Center)
                })
              }
              .width(this.chartData.length * (this.barWidth + this.barSpacing)) // ä½¿ç”¨å¯é…ç½®çš„å®½åº¦è®¡ç®—
              .height(this.chartHeight)
              .alignItems(VerticalAlign.Bottom)
              .padding({ left: 10, right: 10 })
            }
            .scrollable(ScrollDirection.Horizontal)
            .scrollBar(this.showScrollBar ? BarState.Auto : BarState.Off)
            .scrollBarColor(this.getCurrentTheme().borderColor)
            .scrollBarWidth(8)
            .layoutWeight(1)
            .border({ width: 1, color: this.getCurrentTheme().borderColor })
            .borderRadius(4)
            .backgroundColor(this.getCurrentTheme().chartBg ?? this.getCurrentTheme().controlBg ?? this.getCurrentTheme().surfaceColor)
            .onScroll((x: number, y: number) => {
              // ç”¨æˆ·å‘å·¦æ»šåŠ¨ï¼ˆå›çœ‹å†å²ï¼‰åˆ™å…³é—­è‡ªåŠ¨è·Ÿéš
              if (x < this.lastScrollX - 1) {
                this.followLatest = false;
              } else {
                // å½“æ»šåŠ¨æ¥è¿‘æœ«å°¾è‹¥å¹²æŸ±å®½åº¦èŒƒå›´å†…ï¼Œè‡ªåŠ¨æ¢å¤è·Ÿéš
                const contentWidth = this.chartData.length * (this.barWidth + this.barSpacing);
                const nearTailThreshold = 5 * (this.barWidth + this.barSpacing);
                if (x >= Math.max(0, contentWidth - nearTailThreshold)) {
                  this.followLatest = true;
                }
              }
              this.lastScrollX = x;
            })
          }
          .width('100%')
          .height(this.chartHeight)

        }
        .width('100%')
        .padding(20)
        .backgroundColor(this.getCurrentTheme().chartBg ?? this.getCurrentTheme().controlBg ?? this.getCurrentTheme().surfaceColor)
        .borderRadius(8)
        .shadow({
          radius: 10,
          color: 'rgba(0, 0, 0, 0.1)',
          offsetX: 0,
          offsetY: 2
        })
      }
      .width('100%')
      .height('100%')
      .padding(20)
        .backgroundColor(this.getCurrentTheme().pageBg ?? this.getCurrentTheme().surfaceColor)
      .justifyContent(FlexAlign.Start)

      // æç¤ºæ¡†
      if (this.tooltipVisible) {
        Text(this.tooltipText)
          .fontSize(12)
          .fontColor('#FFFFFF')
          .backgroundColor('rgba(0, 0, 0, 0.8)')
          .padding({ left: 10, right: 10, top: 5, bottom: 5 })
          .borderRadius(4)
          .position({ x: this.tooltipX, y: this.tooltipY })
          .zIndex(100)
      }
    }
    .width('100%')
    .height('100%')
  }
}
