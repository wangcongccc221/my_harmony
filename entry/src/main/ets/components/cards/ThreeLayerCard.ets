/**
 * ä¸‰å±‚ç»“æ„å¡ç‰‡ç»„ä»¶
 * åŠŸèƒ½ï¼šæ˜¾ç¤ºä¸‰å±‚ç»“æ„çš„å¡ç‰‡ï¼Œæ— é—´éš”è´´åˆ
 * ç”¨é€”ï¼šæ›¿ä»£åŸæœ‰çš„æ¶²ä½“å¡ç‰‡ï¼Œæä¾›æ›´ä¸°å¯Œçš„æ˜¾ç¤ºå†…å®¹
 */

// TODO(åæœŸè®¡åˆ’ - æ–¹æ¡ˆA å·¥å‚+æ’æ§½):
// é‡‡ç”¨â€œå·¥å‚å‡½æ•° + æ’æ§½(@Builder)â€æ”¹é€ å¡ç‰‡åˆ›å»ºï¼Œä¾¿äºåœ¨ä¸æ”¹ä¸»ä½“é€»è¾‘çš„å‰æä¸‹
// çµæ´»æ’å…¥/æ›¿æ¢å†…å®¹ï¼Œå°¤å…¶æ˜¯ï¼š
// 1) ç¬¬ä¸€å±‚ä¸ç¬¬äºŒå±‚ä¹‹é—´: betweenFirstSecondSlot
// 2) ç¬¬äºŒå±‚ä¸ç¬¬ä¸‰å±‚ä¹‹é—´: betweenSecondThirdSlot
// 3) ç¬¬ä¸‰å±‚å¯æ‰©å±•: thirdPrependSlot / thirdContentSlot / thirdOverlaySlot / thirdAppendSlot
// 4) æ¨¡å¼æ§åˆ¶: thirdMode('data'|'widget'|'custom') + onModeChange
// 5) å·¥å‚ç­¾åç¤ºæ„: createThreeLayerCard(options: {
//      size, theme, enableWave, onDrop,
//      firstLayerSlot?, betweenFirstSecondSlot?, secondLayerSlot?, betweenSecondThirdSlot?,
//      thirdPrependSlot?, thirdContentSlot?, thirdOverlaySlot?, thirdAppendSlot?
//    }) => @Builder
// ä½¿ç”¨å¤„(LiquidCardsArea)ä»…ä¼ å…¥ optionsï¼Œä¸å†ç›´æ¥ä¾èµ–å†…éƒ¨å®ç°ï¼ŒåæœŸå¯è¿­ä»£ç¬¬ä¸‰å±‚è€Œä¸åŠ¨ä¸»æ¸²æŸ“ã€‚
// TODO(æ€§èƒ½ä¼˜åŒ–-è®¡åˆ’):
// - ç¦»å±å¡ç‰‡è‡ªåŠ¨æš‚åœæ³¢æµª: é€šè¿‡å¯è§æ€§/æ»šåŠ¨ç›‘å¬ï¼Œéå¯è§æ—¶æš‚åœ WaveCard å®šæ—¶å™¨ï¼›å¯è§æ—¶æ¢å¤
// - ç¬¬ä¸‰å±‚æ•°æ®æ›´æ–°èŠ‚æµ: é«˜é¢‘æ‹–æ‹½æˆ–åˆå¹¶æ“ä½œæ—¶æ‰¹é‡åˆå¹¶ setState

import { getCurrentCellDragData, CellDragData, CELL_DRAG_ACTIVE_KEY, CELL_DRAG_STORAGE_KEY, MULTI_SELECT_CELLS_KEY, MULTI_SELECT_ACTIVE_KEY, CLEAR_ALL_HIGHLIGHTS_KEY } from '../ui/tables/SimpleDraggableCell'
import { DragData as GridDragData, GRID_DRAG_DATA_KEY, GRID_DRAG_ACTIVE_KEY } from '../layout/DraggableGridTable'
// å¯¼å…¥æ¨¡å—åŒ–çš„æ‹–æ‹½ç®¡ç†å™¨
import { DragManager, DragData as ModuleDragData } from '../../utils/ui/DragManager'
import { DragHandlers } from '../../utils/ui/DragHandlers'
import { GlobalCardDataManager } from '../../utils/GlobalCardDataManager'

import { WaveCard } from '../charts/WaveCard'

// å¯¼å…¥æ–°çš„æ¨¡å—åŒ–ç»„ä»¶
import { 
  SystemWrapper, 
  OuterDropParsed, 
  ThirdLayerDragPayload, 
  FirstLayerData, 
  SecondLayerData, 
  ThirdLayerData, 
  ThreeLayerCardData,
  FirstLayerDataInterface,
  SecondLayerDataInterface,
  ThirdLayerDataInterface,
  DragData,
  RemoveSourceData,
  DragConfig,
  DragOuterPayload,
  LoosePayload,
  LevelStatBatchPayload,
  MultiSelectCell
} from '../ThreeLayerCard/types'
import { UseCardLogic } from '../ThreeLayerCard/hooks/useCardLogic'
import { UseDragHandlers } from '../ThreeLayerCard/hooks/useDragHandlers'
import { UseDragDrop } from '../ThreeLayerCard/hooks/useDragDrop'
import { UseCardState } from '../ThreeLayerCard/hooks/useCardState'
import { UseDataSync } from '../ThreeLayerCard/hooks/useDataSync'
import { StorageKeys } from '../../utils/constants/StorageKeys'
import { FirstLayer } from '../ThreeLayerCard/FirstLayer'
import { SecondLayer } from '../ThreeLayerCard/SecondLayer'
import { ThirdLayer } from '../ThreeLayerCard/ThirdLayer'
import { CardColorConfig } from '../../utils/theme/CardColors'

// æ¥å£å®šä¹‰å·²ç§»è‡³ ThreeLayerCard/types.ets
// é‡æ–°å¯¼å‡º ThreeLayerCardData ä»¥ä¿æŒå‘åå…¼å®¹
export { ThreeLayerCardData } from '../ThreeLayerCard/types'

@Component
export struct ThreeLayerCard {
  // å¡ç‰‡æ•°æ®
  @Prop cardData: ThreeLayerCardData
  
  // å¡ç‰‡å°ºå¯¸
  @Prop cardWidth: number = 150
  @Prop cardHeight: number = 200
  
  // ä¸»è‰²è°ƒ
  @Prop mainColor: string | number | Color = '#EA7A10'
  // æ§åˆ¶ç¬¬ä¸‰å±‚æ˜¯å¦æ˜¾ç¤ºæ³¢æµªå›¾
  @Prop enableWave: boolean = false
  
  // æ‹–æ‹½å›è°ƒ
  onCardDrop?: (data: ThreeLayerCardData) => void
  @State private isHovering: boolean = false
  // æœ¬åœ°å¯è§æ¸²æŸ“ç”¨åˆ—è¡¨ï¼Œç¡®ä¿ç«‹å³å¯è§
  @State private localChartData: number[] = []
  @State private localChartDataStrings: string[] = [] // å­˜å‚¨åŸå§‹å­—ç¬¦ä¸²ï¼ˆåŒ…æ‹¬%ç¬¦å·ï¼‰
  @State private hasOriginalFormatData: boolean = false // æ ‡è®°æ˜¯å¦åŒ…å«åŸå§‹æ ¼å¼æ•°æ®
  // ç¬¬ä¸‰å±‚æ¡ç›®æ‹–æ‹½çš„æœ¬åœ°å…œåº•ç¼“å­˜ï¼ˆé¿å…AppStorageä¸¢å¤±ï¼‰
  @State private pendingDragValue: string = ''
  @State private pendingDragIndex: number = -1
  
  // æ¨¡å—åŒ–çš„æ‹–æ‹½ç®¡ç†å™¨
  private dragManager: DragManager = DragManager.getInstance()
  private dragHandlers: DragHandlers = new DragHandlers()

  aboutToAppear() {
    // åˆå§‹åŒ–æœ¬åœ°å¯è§æ•°ç»„ï¼Œé¿å…é¦–æ¬¡ä¸ºç©ºçœ‹ä¸åˆ°
    this.syncLocalData()
    console.log('ThreeLayerCard aboutToAppear - åŒæ­¥æ•°æ®:', JSON.stringify(this.localChartData))
  }
  
  aboutToUpdate() {
    // åŒæ­¥æœ¬åœ°æ•°æ®ï¼Œç¡®ä¿UIæ›´æ–°
    this.syncLocalData()
  }
  
  private syncLocalData(): void {
    const next = UseDataSync.syncLocalData(this.cardData, {
      localChartData: this.localChartData,
      localChartDataStrings: this.localChartDataStrings,
      hasOriginalFormatData: this.hasOriginalFormatData
    })
    this.localChartData = next.localChartData
    this.localChartDataStrings = next.localChartDataStrings
    this.hasOriginalFormatData = next.hasOriginalFormatData
  }
  
  // åˆ é™¤ç¬¬ä¸‰å±‚é¡¹ç›®çš„æ–¹æ³•
  private deleteItemFromThirdLayer(): void {
    const next = UseDataSync.syncLocalData(this.cardData, {
      localChartData: this.localChartData,
      localChartDataStrings: this.localChartDataStrings,
      hasOriginalFormatData: this.hasOriginalFormatData
    })
    const afterDel = UseDataSync.deleteItemFromThirdLayer(next, this.pendingDragValue, this.pendingDragIndex)
    this.localChartData = afterDel.localChartData
    this.localChartDataStrings = afterDel.localChartDataStrings
    this.hasOriginalFormatData = afterDel.hasOriginalFormatData
    UseDataSync.updateCardData(this.cardData, this.localChartData, this.localChartDataStrings, this.onCardDrop)
    this.pendingDragValue = ''
    this.pendingDragIndex = -1
  }
  
  // æ›´æ–°å¡ç‰‡æ•°æ®çš„æ–¹æ³•
  private updateCardData(newChartData: number[]): void {
    UseDataSync.updateCardData(this.cardData, newChartData, this.localChartDataStrings, this.onCardDrop)
  }
  
  private getCurrentTheme() {
    return UseCardLogic.getCurrentTheme()
  }

  private getCardColors() {
    return UseCardLogic.getCardColors()
  }
  
  private clampPercent(v: number): number {
    return UseCardLogic.clampPercent(v)
  }
  
  // æ ¹æ®å¡ç‰‡IDè·å–æ³¢æµªå›¾é«˜åº¦ç™¾åˆ†æ¯”ï¼šä»å…¨å±€é…ç½®è·å–
  private getWaveHeightPercent(): number {
    return UseCardLogic.getWaveHeightPercent(this.cardData)
  }
  
  // æ ¹æ®å¡ç‰‡IDè·å–æ³¢æµªåŸºå‡†ä½ç½®ç™¾åˆ†æ¯”ï¼šç¬¬1/2/3å¼ å¡åˆ†åˆ« 20%/40%/60%
  private getWaveBaselinePercent(): number {
    return UseCardLogic.getWaveBaselinePercent(this.cardData)
  }
  
  // è·å–å¡ç‰‡åºå·ï¼ˆä»card_0, card_1ç­‰æ ¼å¼ä¸­æå–æ•°å­—+1ï¼‰
  private getCardNumber(): number {
    return UseCardLogic.getCardNumber(this.cardData)
  }

  // è·å–å¡ç‰‡ç´¢å¼•ï¼ˆä»card_0, card_1ç­‰æ ¼å¼ä¸­æå–æ•°å­—ï¼‰
  private getCardIndex(): number {
    return UseCardLogic.getCardIndex(this.cardData)
  }


  /**
   * å¤„ç†SimpleDraggableCellçš„æ‹–æ‹½æŠ•æ”¾
   * @param dragData æ‹–æ‹½æ•°æ®
   */
  private handleCellDragDrop(dragData: CellDragData): void {
    console.log('å¤„ç†SimpleDraggableCellæ‹–æ‹½æ•°æ®:', dragData)
    UseDragDrop.handleCellDragDrop(
      this.cardData,
      String(dragData.value),
      String(dragData.sourceTable || 'ç­‰çº§è¡¨'),
      Number(dragData.rowIndex || 0),
      Number(dragData.colIndex || 0),
      this.onCardDrop
    )
    AppStorage.set(CELL_DRAG_ACTIVE_KEY, false)
  }

  /**
   * è·å–å½“å‰Gridæ‹–æ‹½æ•°æ®
   */
  private getCurrentGridDragData(): GridDragData | null {
    const data = AppStorage.get(GRID_DRAG_DATA_KEY) as GridDragData | null
    return data ?? null
  }

  /**
   * å¤„ç†Gridæ‹–æ‹½æŠ•æ”¾
   * @param dragData Gridæ‹–æ‹½æ•°æ®
   */
  private handleGridDragDrop(dragData: GridDragData): void {
    console.log('å¤„ç†Gridæ‹–æ‹½æ•°æ®:', dragData)
    UseDragDrop.handleGridDragDrop(
      this.cardData,
      String(dragData.item.text),
      String(dragData.sourceTable || 'ç­‰çº§è¡¨'),
      Number(dragData.item.rowIndex || 0),
      Number(dragData.item.colIndex || 0),
      this.onCardDrop
    )
  }

  /**
   * è§¦å‘ç§»é™¤æºå¡ç‰‡æ•°æ®
   */
  private triggerRemoveSourceData(): void {
    const removeData = AppStorage.get('REMOVE_SOURCE_DATA') as RemoveSourceData | null
    if (removeData && removeData.sourceCardId && removeData.sourceValue) {
      console.log('ThreeLayerCardè§¦å‘ç§»é™¤æºå¡ç‰‡æ•°æ®:', removeData)
      // é€šè¿‡AppStorageå‘é€ç§»é™¤ä¿¡å·
      AppStorage.set('FORCE_REMOVE_SOURCE', removeData)
      // æ¸…é™¤åŸå§‹ç§»é™¤æ•°æ®
      AppStorage.set('REMOVE_SOURCE_DATA', null)
    }
  }

  /**
   * å¤„ç†å¤šé€‰æ‹–æ‹½æŠ•æ”¾
   * @param cells é€‰ä¸­çš„å•å…ƒæ ¼æ•°ç»„
   */
  private handleMultiSelectDrop(cells: MultiSelectCell[], levelNames?: string[]): void {
    console.log('ğŸ¯ å¤„ç†å¤šé€‰æ‹–æ‹½ï¼Œå•å…ƒæ ¼æ•°é‡:', cells.length)
    const result = UseDragDrop.handleMultiSelectDrop(this.cardData, cells, levelNames, this.onCardDrop)
    this.localChartData = result.localChartData
    this.localChartDataStrings = result.localChartDataStrings
    this.hasOriginalFormatData = result.hasOriginalFormatData

    // æ¥è‡ªç­‰çº§è¡¨çš„å¤šé€‰ï¼šæŒ‰ç­‰çº§åå»é‡ï¼Œæ‰¹é‡ä¸ŠæŠ¥å‡ºå£ç»Ÿè®¡ï¼ˆä¿ç•™åŸé€»è¾‘ï¼‰
    try {
      const sourceIsLevelTable = String(cells[0]?.sourceTable || '') === 'ç­‰çº§è¡¨'
      if (sourceIsLevelTable) {
        try {
          if (Array.isArray(levelNames) && levelNames.length === cells.length) {
            const cardId = String(this.cardData.id || '')
            const mapRaw = AppStorage.get('CARD_ITEM_LEVEL_MAP') as Record<string, Record<string, string>> | null
            let mapObj: Record<string, Record<string, string>> = mapRaw ? mapRaw : {}
            
            // é™åˆ¶æ˜ å°„å¤§å°ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
            const MAX_MAPPINGS_PER_CARD = 1000
            const MAX_CARDS = 50
            const cardIds = Object.keys(mapObj)
            if (cardIds.length > MAX_CARDS) {
              const limited: Record<string, Record<string, string>> = {}
              cardIds.slice(-MAX_CARDS).forEach(cid => {
                limited[cid] = mapObj[cid]
              })
              mapObj = limited
            }
            
            if (!mapObj[cardId]) { mapObj[cardId] = {} }
            const cardKeys = Object.keys(mapObj[cardId])
            for (let i = 0; i < cells.length; i++) {
              const valStr = String(cells[i]?.value ?? '')
              const ln = String(levelNames[i] ?? '')
              if (valStr && ln) {
                // å¦‚æœè¶…è¿‡é™åˆ¶ï¼Œç§»é™¤æœ€æ—§çš„æ˜ å°„ï¼ˆä½¿ç”¨é‡æ–°åˆ›å»ºå¯¹è±¡çš„æ–¹å¼ï¼Œé¿å…ä½¿ç”¨ deleteï¼‰
                if (cardKeys.length >= MAX_MAPPINGS_PER_CARD && !mapObj[cardId][valStr]) {
                  const oldestKey = cardKeys[0]
                  // é‡æ–°åˆ›å»ºå¯¹è±¡ï¼Œæ’é™¤è¦åˆ é™¤çš„é”®
                  const newCardMap: Record<string, string> = {}
                  Object.keys(mapObj[cardId]).forEach(key => {
                    if (key !== oldestKey) {
                      newCardMap[key] = mapObj[cardId][key]
                    }
                  })
                  mapObj[cardId] = newCardMap
                  cardKeys.shift()
                }
                mapObj[cardId][valStr] = ln
                if (!cardKeys.includes(valStr)) {
                  cardKeys.push(valStr)
                }
              }
            }
            AppStorage.setOrCreate('CARD_ITEM_LEVEL_MAP', mapObj)
          }
        } catch (_e) {}
        let collected: string[] = Array.isArray(levelNames) ? levelNames : []
        if (!Array.isArray(levelNames) || levelNames.length === 0) {
          collected = cells.map((_cell: MultiSelectCell) => '')
        }
        const uniqueLevels = Array.from(new Set(collected)).filter(s => s && s.length > 0)
        if (uniqueLevels.length > 0) {
          const exitNum = this.getCardNumber()
          const batchPayload: LevelStatBatchPayload = { levelNames: uniqueLevels, exit: exitNum }
          AppStorage.setOrCreate('LEVEL_STAT_UPDATE_BATCH', batchPayload)
        }
      }
    } catch (_e) {}
    
    console.log('å¤šé€‰æ‹–æ‹½å®Œæˆï¼Œå½“å‰æœ¬åœ°æ•°é‡:', this.localChartData.length)
  }

  /**
   * å¤„ç†ç¬¬ä¸‰å±‚çš„æ‹–æ‹½æŠ•æ”¾äº‹ä»¶
   * @param event æ‹–æ‹½äº‹ä»¶
   * @param extraParams é¢å¤–å‚æ•°
   */
  private handleThirdLayerDrop(event: DragEvent, extraParams: string): void {
    if (!extraParams) {
      UseCardState.resetDragStates()
      this.isHovering = false
            return
          }
    try {
      const next = UseDragDrop.handleThirdLayerDrop(
        extraParams,
        this.cardData,
        {
          localChartData: this.localChartData,
          localChartDataStrings: this.localChartDataStrings,
          hasOriginalFormatData: this.hasOriginalFormatData
        },
        this.onCardDrop,
        () => this.getCardNumber()
      )
      this.localChartData = next.localChartData
      this.localChartDataStrings = next.localChartDataStrings
      this.hasOriginalFormatData = next.hasOriginalFormatData
      } catch (error) {
      console.error('å¤„ç†æ‹–æ‹½æ•°æ®å¤±è´¥:', error)
    }
    UseCardState.resetDragStates()
    this.isHovering = false
  }
  
  build() {
    Column() {
      // ç¬¬ä¸€å±‚ï¼šå›¾ç‰‡/æ–‡å­—å±‚
      FirstLayer({
        cardData: this.cardData,
        cardHeight: this.cardHeight,
        cardColors: this.getCardColors()
      })
      
      // ç¬¬ä¸€å±‚å’Œç¬¬äºŒå±‚ä¹‹é—´çš„åˆ†éš”çº¿
      Divider()
        .strokeWidth(1)
        .color(this.getCardColors().cardBorder)
        .opacity(0.8)
      
      // ç¬¬äºŒå±‚ï¼šä¿¡æ¯æ˜¾ç¤ºå±‚
      SecondLayer({
        cardData: this.cardData,
        cardHeight: this.cardHeight,
        enableWave: this.enableWave,
        cardColors: this.getCardColors(),
        cardNumber: this.getCardNumber(),
        waveHeightPercent: this.getWaveHeightPercent()
      })
      
      // ç¬¬äºŒå±‚å’Œç¬¬ä¸‰å±‚ä¹‹é—´çš„åˆ†éš”çº¿
      Divider()
        .strokeWidth(1)
        .color(this.getCardColors().cardBorder)
        .opacity(0.8)
      
      // ç¬¬ä¸‰å±‚ï¼šæ³¢å½¢å›¾å±‚ï¼ˆæ”¯æŒæ‹–æ‹½æŠ•æ”¾ï¼‰
      ThirdLayer({
        cardData: this.cardData,
        enableWave: this.enableWave,
        localChartData: this.localChartData,
        localChartDataStrings: this.localChartDataStrings,
        hasOriginalFormatData: this.hasOriginalFormatData,
        pendingDragValue: this.pendingDragValue,
        pendingDragIndex: this.pendingDragIndex,
        cardColors: this.getCardColors(),
        waveHeightPercent: this.getWaveHeightPercent(),
        waveBaselinePercent: this.getWaveBaselinePercent(),
        cardNumber: this.getCardNumber(),
        onCachePending: (value: string, index: number) => {
          // åŒæ­¥å­ç»„ä»¶çš„æ‹–æ‹½ç¼“å­˜åˆ°çˆ¶ç»„ä»¶ï¼Œç¡®ä¿åˆ é™¤é€»è¾‘å¯å‘½ä¸­
          this.pendingDragValue = value
          this.pendingDragIndex = index
        },
        onDropCallback: (event, params) => this.handleThirdLayerDrop(event, params),
        onDragEnterCallback: () => { this.isHovering = true },
        onDragLeaveCallback: () => { this.isHovering = false },
        onTouchCallback: () => {
          // æ£€æŸ¥æ˜¯å¦æœ‰Gridæ‹–æ‹½æ•°æ®
          const gridDragData = this.getCurrentGridDragData()
          if (gridDragData) {
            console.log('ç¬¬ä¸‰å±‚æ¥æ”¶åˆ°Gridæ‹–æ‹½æ•°æ®:', gridDragData)
            this.handleGridDragDrop(gridDragData)
          }
        },
        deleteItemFromThirdLayer: () => this.deleteItemFromThirdLayer()
      })
    }
    .width(this.cardWidth)
    .height(this.cardHeight)
    .backgroundColor(Color.Transparent) // é€æ˜èƒŒæ™¯
    .borderRadius(12) // åœ†è§’
    .border({ width: 2, color: UseCardLogic.getCardColors().cardBorder }) // å¡ç‰‡è¾¹æ¡†
    .shadow({ radius: 10, color: UseCardLogic.getCardColors().cardShadow, offsetX: 0, offsetY: 4 }) // å¡ç‰‡é˜´å½±
    .clip(true) // è£å‰ªå­ç»„ä»¶
    .onClick(() => {
      this.onCardDrop?.(this.cardData)
    })
    // å¤§å¡ç‰‡å¤–å±‚ï¼šè½åœ¨å¡ç‰‡å®¹å™¨ï¼ˆç¬¬ä¸€/ç¬¬äºŒå±‚æˆ–å¡ç‰‡è¾¹å†…ç©ºç™½ï¼‰è§†ä¸ºâ€œå†…å®¹ä¸å˜â€
    .onDrop((event: DragEvent, extraParams: string) => {
      UseDragDrop.handleOuterDrop(extraParams)
      // å¤–å±‚å®¹å™¨ä¸æ”¹å˜ handled æ ‡å¿—ï¼Œé¿å…è¦†ç›–çœŸå®ç›®æ ‡å±‚çš„å¤„ç†ç»“æœ
    })
  }
  
  /**
   * æ„å»ºæ‹–æ‹½é¢„è§ˆ
   */
  @Builder
  private buildDragPreview(value: number) {
    Text(`${value}`)
      .fontSize(12)
      .fontWeight(FontWeight.Medium)
      .fontColor(Color.White)
      .backgroundColor(this.mainColor)
      .padding({ left: 8, right: 8, top: 4, bottom: 4 })
      .borderRadius(4)
  }
}
