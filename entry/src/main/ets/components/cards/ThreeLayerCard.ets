import { getCurrentCellDragData, CellDragData, CELL_DRAG_ACTIVE_KEY, CELL_DRAG_STORAGE_KEY, MULTI_SELECT_CELLS_KEY, MULTI_SELECT_ACTIVE_KEY, CLEAR_ALL_HIGHLIGHTS_KEY } from '../ui/tables/SimpleDraggableCell'
import { DragData as GridDragData, GRID_DRAG_DATA_KEY, GRID_DRAG_ACTIVE_KEY } from '../layout/DraggableGridTable'
// å¯¼å…¥æ¨¡å—åŒ–çš„æ‹–æ‹½ç®¡ç†å™¨
import { DragManager, DragData as ModuleDragData } from '../../utils/ui/DragManager'
import { DragHandlers } from '../../utils/ui/DragHandlers'
import { GlobalCardDataManager } from '../../utils/managers/GlobalCardDataManager'
import { HOME_SELECTED_FSM } from '../../constants/TopBarKeys'
import { ExitConfigManager, FsmKey, OutletConfig } from '../../pages/home/core/ExitConfigManager'

import { WaveCard } from '../charts/WaveCard'

// å¯¼å…¥æ–°çš„æ¨¡å—åŒ–ç»„ä»¶
import { 
  SystemWrapper, 
  OuterDropParsed, 
  ThirdLayerDragPayload, 
  FirstLayerData, 
  SecondLayerData, 
  ThirdLayerData, 
  ThreeLayerCardData,
  FirstLayerDataInterface,
  SecondLayerDataInterface,
  ThirdLayerDataInterface,
  DragData,
  RemoveSourceData,
  DragConfig,
  DragOuterPayload,
  LoosePayload,
  LevelStatBatchPayload,
  MultiSelectCell
} from '../ThreeLayerCard/types'
import { UseCardLogic } from '../ThreeLayerCard/hooks/useCardLogic'
import { UseDragHandlers } from '../ThreeLayerCard/hooks/useDragHandlers'
import { UseDragDrop } from '../ThreeLayerCard/hooks/useDragDrop'
import { UseCardState } from '../ThreeLayerCard/hooks/useCardState'
import { UseDataSync, SyncState } from '../ThreeLayerCard/hooks/useDataSync'
import { StorageKeys } from '../../utils/constants/StorageKeys'
import { FirstLayer } from '../ThreeLayerCard/FirstLayer'
import { SecondLayer } from '../ThreeLayerCard/SecondLayer'
import { ThirdLayer } from '../ThreeLayerCard/ThirdLayer'
import { CardColorConfig } from '../../utils/theme/CardColors'
import { HomeDataManager } from '../../pages/home/core/HomeDataManager'
import { OmniUIUtils } from '../../utils/helpers/OmniUIUtils'

// æ¥å£å®šä¹‰å·²ç§»è‡³ ThreeLayerCard/types.ets
export { ThreeLayerCardData } from '../ThreeLayerCard/types'

interface CardMouseEvent {
  button?: number
}

interface ClipboardPayload {
  chartData: number[]
  chartDataStrings?: string[]
  hasOriginalFormatData?: boolean
}

@Component
export struct ThreeLayerCard {
  // å¡ç‰‡æ•°æ®
  @Prop cardData: ThreeLayerCardData
  
  // å¡ç‰‡å°ºå¯¸
  @Prop cardWidth: string | number = 150
  @Prop cardHeight: string | number = 200
  
  // ä¸»è‰²è°ƒ
  @Prop mainColor: string | number | Color = '#EA7A10'
  // æ§åˆ¶ç¬¬ä¸‰å±‚æ˜¯å¦æ˜¾ç¤ºæ³¢æµªå›¾
  @Prop enableWave: boolean = false
  
  // æ‹–æ‹½å›è°ƒ
  onCardDrop?: (data: ThreeLayerCardData) => void
  // ç¬¬ä¸‰å±‚ç‚¹å‡»å›è°ƒ
  onThirdLayerClick?: () => void
  @State private isHovering: boolean = false
  // æœ¬åœ°å¯è§æ¸²æŸ“ç”¨åˆ—è¡¨ï¼Œç¡®ä¿ç«‹å³å¯è§
  @State private localChartData: number[] = []
  @State private localChartDataStrings: string[] = [] // å­˜å‚¨åŸå§‹å­—ç¬¦ä¸²ï¼ˆåŒ…æ‹¬%ç¬¦å·ï¼‰
  @State private hasOriginalFormatData: boolean = false // æ ‡è®°æ˜¯å¦åŒ…å«åŸå§‹æ ¼å¼æ•°æ®
  // ç¬¬ä¸‰å±‚æ¡ç›®æ‹–æ‹½çš„æœ¬åœ°å…œåº•ç¼“å­˜ï¼ˆé¿å…AppStorageä¸¢å¤±ï¼‰
  @State private pendingDragValue: string = ''
  @State private pendingDragIndex: number = -1
  @State private showContextMenu: boolean = false
  private readonly clipboardKey: string = 'LIQUID_CARD_CLIPBOARD'
  
  // æ¨¡å—åŒ–çš„æ‹–æ‹½ç®¡ç†å™¨
  private dragManager: DragManager = DragManager.getInstance()
  private dragHandlers: DragHandlers = new DragHandlers()

  aboutToAppear() {
    // åˆå§‹åŒ–æœ¬åœ°å¯è§æ•°ç»„ï¼Œé¿å…é¦–æ¬¡ä¸ºç©ºçœ‹ä¸åˆ°
    this.syncLocalData()
    console.log('ThreeLayerCard aboutToAppear - åŒæ­¥æ•°æ®:', JSON.stringify(this.localChartData))
  }
  
  aboutToUpdate() {
    // åŒæ­¥æœ¬åœ°æ•°æ®ï¼Œç¡®ä¿UIæ›´æ–°
    this.syncLocalData()
  }

  
  private syncLocalData(): void {
    const next = UseDataSync.syncLocalData(this.cardData, {
      localChartData: this.localChartData,
      localChartDataStrings: this.localChartDataStrings,
      hasOriginalFormatData: this.hasOriginalFormatData
    })
    this.localChartData = next.localChartData
    this.localChartDataStrings = next.localChartDataStrings
    this.hasOriginalFormatData = next.hasOriginalFormatData
  }
  
  // åˆ é™¤ç¬¬ä¸‰å±‚é¡¹ç›®çš„æ–¹æ³•
  private deleteItemFromThirdLayer(): void {
    // ç›´æ¥ä½¿ç”¨å½“å‰æœ¬åœ°æ•°æ®è¿›è¡Œåˆ é™¤ï¼Œä¸å¼ºåˆ¶åŒæ­¥çˆ¶ç»„ä»¶æ•°æ®ï¼Œé¿å…å¤šé€‰æ‹–æ‹½åçˆ¶ç»„ä»¶æ•°æ®æ›´æ–°å»¶è¿Ÿå¯¼è‡´çš„æ•°æ®ä¸¢å¤±
    const current: SyncState = {
      localChartData: this.localChartData,
      localChartDataStrings: this.localChartDataStrings,
      hasOriginalFormatData: this.hasOriginalFormatData
    }
    const afterDel = UseDataSync.deleteItemFromThirdLayer(current, this.pendingDragValue, this.pendingDragIndex)
    this.localChartData = afterDel.localChartData
    this.localChartDataStrings = afterDel.localChartDataStrings
    this.hasOriginalFormatData = afterDel.hasOriginalFormatData
    UseDataSync.updateCardData(this.cardData, this.localChartData, this.localChartDataStrings, this.onCardDrop)
    this.pendingDragValue = ''
    this.pendingDragIndex = -1
  }
  
  // æ›´æ–°å¡ç‰‡æ•°æ®çš„æ–¹æ³•
  private updateCardData(newChartData: number[]): void {
    UseDataSync.updateCardData(this.cardData, newChartData, this.localChartDataStrings, this.onCardDrop)
  }
  
  private getCurrentTheme() {
    return UseCardLogic.getCurrentTheme()
  }

  private getCardColors() {
    return UseCardLogic.getCardColors()
  }
  
  private clampPercent(v: number): number {
    return UseCardLogic.clampPercent(v)
  }

  private getSelectedFsm(): FsmKey {
    const value = AppStorage.get(HOME_SELECTED_FSM) as FsmKey | undefined
    return value ?? 'FSM1'
  }

  private getExitConfig(): OutletConfig {
    const fsm = this.getSelectedFsm()
    const exitIndex = this.getCardNumber()
    return ExitConfigManager.getInstance().getExitConfig(fsm, exitIndex)
  }

  private async setExitEnabled(enabled: boolean): Promise<void> {
    const fsm = this.getSelectedFsm()
    const exitIndex = this.getCardNumber()
    const config = ExitConfigManager.getInstance().getExitConfig(fsm, exitIndex)
    config.outletEnable = enabled ? 'å¼€å¯' : 'å…³é—­'
    config.enabled = enabled
    ExitConfigManager.getInstance().setExitConfig(fsm, config)
    await ExitConfigManager.getInstance().sendExitConfig(fsm)
  }

  private clearCardMapping(): void {
    const cardId = String(this.cardData.id || '')
    const mapRaw = AppStorage.get('CARD_ITEM_LEVEL_MAP') as Record<string, Record<string, string>> | null
    if (!mapRaw || !mapRaw[cardId]) {
      return
    }
    const next: Record<string, Record<string, string>> = {}
    Object.keys(mapRaw).forEach(key => {
      if (key !== cardId) {
        next[key] = mapRaw[key]
      }
    })
    AppStorage.setOrCreate('CARD_ITEM_LEVEL_MAP', next)
  }

  private clearCardData(): void {
    this.localChartData = []
    this.localChartDataStrings = []
    this.hasOriginalFormatData = false
    this.clearCardMapping()
    UseDataSync.updateCardData(this.cardData, [], [], this.onCardDrop)
  }

  private copyCardData(): void {
    const payload: ClipboardPayload = {
      chartData: this.localChartData.slice(),
      chartDataStrings: this.localChartDataStrings.slice(),
      hasOriginalFormatData: this.hasOriginalFormatData
    }
    AppStorage.setOrCreate(this.clipboardKey, payload)
  }

  private hasClipboardData(): boolean {
    const payload = AppStorage.get(this.clipboardKey) as ClipboardPayload | undefined
    return !!payload && Array.isArray(payload.chartData) && payload.chartData.length > 0
  }

  private pasteCardData(): void {
    const payload = AppStorage.get(this.clipboardKey) as ClipboardPayload | undefined
    if (!payload || !Array.isArray(payload.chartData)) {
      return
    }
    const nextData = payload.chartData.slice()
    const nextStrings = Array.isArray(payload.chartDataStrings) && payload.chartDataStrings.length > 0
      ? payload.chartDataStrings.slice()
      : nextData.map(item => String(item))
    const hasOriginal = typeof payload.hasOriginalFormatData === 'boolean'
      ? payload.hasOriginalFormatData
      : nextStrings.some(str => str.includes('%'))
    this.localChartData = nextData
    this.localChartDataStrings = nextStrings
    this.hasOriginalFormatData = hasOriginal
    UseDataSync.updateCardData(this.cardData, nextData, nextStrings, this.onCardDrop)
  }

  private cutCardData(): void {
    this.copyCardData()
    this.clearCardData()
  }

  private isExitRunning(): boolean {
    const config = this.getExitConfig()
    return config.outletEnable === 'å¼€å¯' && config.enabled
  }

  private canPaste(): boolean {
    return this.hasClipboardData()
  }

  private getMappedLevelNames(): string[] {
    const cardId = String(this.cardData.id || '')
    const mapRaw = AppStorage.get('CARD_ITEM_LEVEL_MAP') as Record<string, Record<string, string>> | null
    if (!mapRaw || !mapRaw[cardId]) {
      return []
    }
    const names = Object.values(mapRaw[cardId]).map(v => String(v ?? '')).filter(v => v.length > 0)
    return Array.from(new Set(names))
  }

  private splitExitLabels(value: string): string[] {
    if (!value) {
      return []
    }
    return value.split(/[,ï¼Œ/ã€\s]+/).map(item => item.trim()).filter(item => item.length > 0)
  }

  private getLevelsOnlyInThisExit(): string[] {
    const exitNumber = this.getCardNumber()
    const exitLabel = `å‡ºå£${exitNumber}`
    const dataManager = HomeDataManager.getInstance()
    dataManager.setFSM(this.getSelectedFsm())
    const rows = dataManager.getTableData('ç­‰çº§ç»Ÿè®¡è¡¨')
    const targets = new Set(this.getMappedLevelNames())
    const result: string[] = []
    rows.forEach(row => {
      const levelName = String(row[0] ?? '')
      if (!targets.has(levelName)) {
        return
      }
      const labels = this.splitExitLabels(String(row[2] ?? ''))
      if (labels.length === 1 && labels[0] === exitLabel) {
        result.push(levelName)
      }
    })
    return result
  }

  private removeExitFromStatistics(levelNames: string[], exit: number): void {
    if (!Array.isArray(levelNames) || levelNames.length === 0) {
      return
    }
    levelNames.forEach(levelName => {
      AppStorage.setOrCreate(StorageKeys.LEVEL_STAT_REMOVE, { levelName: levelName, exit: exit })
    })
  }
  
  // æ ¹æ®å¡ç‰‡IDè·å–æ³¢æµªå›¾é«˜åº¦ç™¾åˆ†æ¯”ï¼šä½¿ç”¨å®æ—¶æ•°æ®
  private getWaveHeightPercent(): number {
    // ä¼˜å…ˆä½¿ç”¨å¡ç‰‡æ•°æ®ä¸­çš„å®æ—¶ç™¾åˆ†æ¯”
    if (this.cardData && this.cardData.secondLayer && typeof this.cardData.secondLayer.percent === 'number') {
      return this.cardData.secondLayer.percent
    }
    return UseCardLogic.getWaveHeightPercent(this.cardData)
  }
  
  // æ ¹æ®å¡ç‰‡IDè·å–æ³¢æµªåŸºå‡†ä½ç½®ç™¾åˆ†æ¯”ï¼šç¬¬1/2/3å¼ å¡åˆ†åˆ« 20%/40%/60%
  private getWaveBaselinePercent(): number {
    return UseCardLogic.getWaveBaselinePercent(this.cardData)
  }
  
  // è·å–å¡ç‰‡åºå·ï¼ˆä»card_0, card_1ç­‰æ ¼å¼ä¸­æå–æ•°å­—+1ï¼‰
  private getCardNumber(): number {
    return UseCardLogic.getCardNumber(this.cardData)
  }

  // è·å–å¡ç‰‡ç´¢å¼•ï¼ˆä»card_0, card_1ç­‰æ ¼å¼ä¸­æå–æ•°å­—ï¼‰
  private getCardIndex(): number {
    return UseCardLogic.getCardIndex(this.cardData)
  }

  // åˆ¤æ–­å¡ç‰‡æ˜¯å¦ä¸ºç©ºç™½æ ¼å­ï¼ˆæ²¡æœ‰æ•°æ®ä¸”ä¸æ˜¾ç¤ºæ³¢æµªå›¾ï¼‰
  private isEmptyCard(): boolean {
    const hasData = this.localChartData && this.localChartData.length > 0
    const hasWave = this.enableWave
    // æ³¨æ„ï¼šå¦‚æœæœ‰æ•°æ® OR æœ‰æ³¢æµªï¼Œéƒ½ä¸ç®—ç©ºå¡ç‰‡
    return !hasData && !hasWave
  }


  /**
   * å¤„ç†SimpleDraggableCellçš„æ‹–æ‹½æŠ•æ”¾
   * @param dragData æ‹–æ‹½æ•°æ®
   */
  private handleCellDragDrop(dragData: CellDragData): void {
    console.log('å¤„ç†SimpleDraggableCellæ‹–æ‹½æ•°æ®:', dragData)
    UseDragDrop.handleCellDragDrop(
      this.cardData,
      String(dragData.value),
      String(dragData.sourceTable || 'ç­‰çº§è¡¨'),
      Number(dragData.rowIndex || 0),
      Number(dragData.colIndex || 0),
      this.onCardDrop
    )
    AppStorage.set(CELL_DRAG_ACTIVE_KEY, false)
  }

  /**
   * è·å–å½“å‰Gridæ‹–æ‹½æ•°æ®
   */
  private getCurrentGridDragData(): GridDragData | null {
    const data = AppStorage.get(GRID_DRAG_DATA_KEY) as GridDragData | null
    return data ?? null
  }

  /**
   * å¤„ç†Gridæ‹–æ‹½æŠ•æ”¾
   * @param dragData Gridæ‹–æ‹½æ•°æ®
   */
  private handleGridDragDrop(dragData: GridDragData): void {
    console.log('å¤„ç†Gridæ‹–æ‹½æ•°æ®:', dragData)
    UseDragDrop.handleGridDragDrop(
      this.cardData,
      String(dragData.item.text),
      String(dragData.sourceTable || 'ç­‰çº§è¡¨'),
      Number(dragData.item.rowIndex || 0),
      Number(dragData.item.colIndex || 0),
      this.onCardDrop
    )
  }

  /**
   * è§¦å‘ç§»é™¤æºå¡ç‰‡æ•°æ®
   */
  private triggerRemoveSourceData(): void {
    const removeData = AppStorage.get('REMOVE_SOURCE_DATA') as RemoveSourceData | null
    if (removeData && removeData.sourceCardId && removeData.sourceValue) {
      console.log('ThreeLayerCardè§¦å‘ç§»é™¤æºå¡ç‰‡æ•°æ®:', removeData)
      // é€šè¿‡AppStorageå‘é€ç§»é™¤ä¿¡å·
      AppStorage.set('FORCE_REMOVE_SOURCE', removeData)
      // æ¸…é™¤åŸå§‹ç§»é™¤æ•°æ®
      AppStorage.set('REMOVE_SOURCE_DATA', null)
    }
  }

  /**
   * å¤„ç†å¤šé€‰æ‹–æ‹½æŠ•æ”¾
   * @param cells é€‰ä¸­çš„å•å…ƒæ ¼æ•°ç»„
   */
  private handleMultiSelectDrop(cells: MultiSelectCell[], levelNames?: string[]): void {
    console.log('ğŸ¯ å¤„ç†å¤šé€‰æ‹–æ‹½ï¼Œå•å…ƒæ ¼æ•°é‡:', cells.length)
    const result = UseDragDrop.handleMultiSelectDrop(this.cardData, cells, levelNames, this.onCardDrop)
    this.localChartData = result.localChartData
    this.localChartDataStrings = result.localChartDataStrings
    this.hasOriginalFormatData = result.hasOriginalFormatData

    // æ¥è‡ªç­‰çº§è¡¨çš„å¤šé€‰ï¼šæŒ‰ç­‰çº§åå»é‡ï¼Œæ‰¹é‡ä¸ŠæŠ¥å‡ºå£ç»Ÿè®¡ï¼ˆä¿ç•™åŸé€»è¾‘ï¼‰
    try {
      const sourceIsLevelTable = String(cells[0]?.sourceTable || '') === 'ç­‰çº§è¡¨'
      if (sourceIsLevelTable) {
        try {
          if (Array.isArray(levelNames) && levelNames.length === cells.length) {
            const cardId = String(this.cardData.id || '')
            const mapRaw = AppStorage.get('CARD_ITEM_LEVEL_MAP') as Record<string, Record<string, string>> | null
            let mapObj: Record<string, Record<string, string>> = mapRaw ? mapRaw : {}
            
            // é™åˆ¶æ˜ å°„å¤§å°ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
            const MAX_MAPPINGS_PER_CARD = 1000
            const MAX_CARDS = 50
            const cardIds = Object.keys(mapObj)
            if (cardIds.length > MAX_CARDS) {
              const limited: Record<string, Record<string, string>> = {}
              cardIds.slice(-MAX_CARDS).forEach(cid => {
                limited[cid] = mapObj[cid]
              })
              mapObj = limited
            }
            
            if (!mapObj[cardId]) { mapObj[cardId] = {} }
            const cardKeys = Object.keys(mapObj[cardId])
            for (let i = 0; i < cells.length; i++) {
              const valStr = String(cells[i]?.value ?? '')
              const ln = String(levelNames[i] ?? '')
              if (valStr && ln) {
                // å¦‚æœè¶…è¿‡é™åˆ¶ï¼Œç§»é™¤æœ€æ—§çš„æ˜ å°„ï¼ˆä½¿ç”¨é‡æ–°åˆ›å»ºå¯¹è±¡çš„æ–¹å¼ï¼Œé¿å…ä½¿ç”¨ deleteï¼‰
                if (cardKeys.length >= MAX_MAPPINGS_PER_CARD && !mapObj[cardId][valStr]) {
                  const oldestKey = cardKeys[0]
                  // é‡æ–°åˆ›å»ºå¯¹è±¡ï¼Œæ’é™¤è¦åˆ é™¤çš„é”®
                  const newCardMap: Record<string, string> = {}
                  Object.keys(mapObj[cardId]).forEach(key => {
                    if (key !== oldestKey) {
                      newCardMap[key] = mapObj[cardId][key]
                    }
                  })
                  mapObj[cardId] = newCardMap
                  cardKeys.shift()
                }
                mapObj[cardId][valStr] = ln
                if (!cardKeys.includes(valStr)) {
                  cardKeys.push(valStr)
                }
              }
            }
            AppStorage.setOrCreate('CARD_ITEM_LEVEL_MAP', mapObj)
          }
        } catch (_e) {}
        let collected: string[] = Array.isArray(levelNames) ? levelNames : []
        if (!Array.isArray(levelNames) || levelNames.length === 0) {
          collected = cells.map((_cell: MultiSelectCell) => '')
        }
        const uniqueLevels = Array.from(new Set(collected)).filter(s => s && s.length > 0)
        if (uniqueLevels.length > 0) {
          const exitNum = this.getCardNumber()
          const batchPayload: LevelStatBatchPayload = { levelNames: uniqueLevels, exit: exitNum }
          AppStorage.setOrCreate('LEVEL_STAT_UPDATE_BATCH', batchPayload)
        }
      }
    } catch (_e) {}
    
    console.log('å¤šé€‰æ‹–æ‹½å®Œæˆï¼Œå½“å‰æœ¬åœ°æ•°é‡:', this.localChartData.length)
  }

  /**
   * å¤„ç†ç¬¬ä¸‰å±‚çš„æ‹–æ‹½æŠ•æ”¾äº‹ä»¶
   * @param event æ‹–æ‹½äº‹ä»¶
   * @param extraParams é¢å¤–å‚æ•°
   */
  private handleThirdLayerDrop(event: DragEvent, extraParams: string): void {
    if (!extraParams) {
      UseCardState.resetDragStates()
      this.isHovering = false
            return
          }
    try {
      const next = UseDragDrop.handleThirdLayerDrop(
        extraParams,
        this.cardData,
        {
          localChartData: this.localChartData,
          localChartDataStrings: this.localChartDataStrings,
          hasOriginalFormatData: this.hasOriginalFormatData
        },
        this.onCardDrop,
        () => this.getCardNumber()
      )
      this.localChartData = next.localChartData
      this.localChartDataStrings = next.localChartDataStrings
      this.hasOriginalFormatData = next.hasOriginalFormatData
      } catch (error) {
      console.error('å¤„ç†æ‹–æ‹½æ•°æ®å¤±è´¥:', error)
    }
    UseCardState.resetDragStates()
    this.isHovering = false
  }

  private handleMouseEvent(event?: CardMouseEvent): void {
    if (!event) {
      return
    }
    if (event.button === 2) {
      this.showContextMenu = true
    }
  }
  
  @Builder
  private buildContextMenu() {
    Column() {
      Button() {
        Text('å¯åŠ¨')
          .fontSize(16)
          .fontColor(this.getCurrentTheme().textColor)
          .fontWeight(FontWeight.Medium)
          .textAlign(TextAlign.Center)
          .width('100%')
      }
      .width(140)
      .height(40)
      .backgroundColor(Color.Transparent)
      .stateEffect(true)
      .enabled(!this.isExitRunning())
      .onClick(() => {
        this.showContextMenu = false
        this.setExitEnabled(true)
      })
      Button() {
        Text('æš‚åœ')
          .fontSize(16)
          .fontColor(this.getCurrentTheme().textColor)
          .fontWeight(FontWeight.Medium)
          .textAlign(TextAlign.Center)
          .width('100%')
      }
      .width(140)
      .height(40)
      .backgroundColor(Color.Transparent)
      .stateEffect(true)
      .enabled(this.isExitRunning())
      .onClick(() => {
        this.showContextMenu = false
        this.setExitEnabled(false)
        const lost = this.getLevelsOnlyInThisExit()
        if (lost.length > 0) {
          OmniUIUtils.getInstance().showInfo(`ä»¥ä¸‹ç­‰çº§ä»…åœ¨å‡ºå£${this.getCardNumber()}ï¼š${lost.join('ã€')}`)
        }
      })
      Button() {
        Text('æ‰“å¼€')
          .fontSize(16)
          .fontColor(this.getCurrentTheme().textColor)
          .fontWeight(FontWeight.Medium)
          .textAlign(TextAlign.Center)
          .width('100%')
      }
      .width(140)
      .height(40)
      .backgroundColor(Color.Transparent)
      .stateEffect(true)
      .onClick(() => {
        this.showContextMenu = false
        if (!this.isExitRunning()) {
          return
        }
        if (this.onThirdLayerClick) {
          this.onThirdLayerClick()
        }
      })
      Button() {
        Text('æ¸…ç©º')
          .fontSize(16)
          .fontColor(this.getCurrentTheme().textColor)
          .fontWeight(FontWeight.Medium)
          .textAlign(TextAlign.Center)
          .width('100%')
      }
      .width(140)
      .height(40)
      .backgroundColor(Color.Transparent)
      .stateEffect(true)
      .onClick(() => {
        this.showContextMenu = false
        if (!this.isExitRunning()) {
          return
        }
        const levelNames = this.getMappedLevelNames()
        this.removeExitFromStatistics(levelNames, this.getCardNumber())
        this.clearCardData()
      })
      Button() {
        Text('å¤åˆ¶')
          .fontSize(16)
          .fontColor(this.getCurrentTheme().textColor)
          .fontWeight(FontWeight.Medium)
          .textAlign(TextAlign.Center)
          .width('100%')
      }
      .width(140)
      .height(40)
      .backgroundColor(Color.Transparent)
      .stateEffect(true)
      .onClick(() => {
        this.showContextMenu = false
        this.copyCardData()
      })
      Button() {
        Text('å‰ªåˆ‡')
          .fontSize(16)
          .fontColor(this.getCurrentTheme().textColor)
          .fontWeight(FontWeight.Medium)
          .textAlign(TextAlign.Center)
          .width('100%')
      }
      .width(140)
      .height(40)
      .backgroundColor(Color.Transparent)
      .stateEffect(true)
      .onClick(() => {
        this.showContextMenu = false
        if (!this.isExitRunning()) {
          return
        }
        const levelNames = this.getMappedLevelNames()
        this.removeExitFromStatistics(levelNames, this.getCardNumber())
        this.cutCardData()
      })
      Button() {
        Text('ç²˜è´´')
          .fontSize(16)
          .fontColor(this.getCurrentTheme().textColor)
          .fontWeight(FontWeight.Medium)
          .textAlign(TextAlign.Center)
          .width('100%')
      }
      .width(140)
      .height(40)
      .backgroundColor(Color.Transparent)
      .stateEffect(true)
      .enabled(this.canPaste())
      .onClick(() => {
        this.showContextMenu = false
        this.pasteCardData()
      })
    }
    .width(160)
    .padding(4)
    .backgroundColor(this.getCurrentTheme().surfaceColor)
    .borderRadius(12)
    .shadow({ radius: 12, color: 'rgba(0, 0, 0, 0.12)', offsetX: 0, offsetY: 4 })
    .border({ width: 1, color: this.getCurrentTheme().borderColor + '40' })
  }

  build() {
    Column() {
      // ç¬¬ä¸€å±‚ï¼šå›¾ç‰‡/æ–‡å­—å±‚
      FirstLayer({
        cardData: this.cardData,
        cardColors: this.getCardColors()
      })
      
      // ç¬¬ä¸€å±‚å’Œç¬¬äºŒå±‚ä¹‹é—´çš„åˆ†éš”çº¿
      Divider()
        .strokeWidth(1)
        .color(this.getCardColors().cardBorder)
        .opacity(0.8)
      
      // ç¬¬äºŒå±‚ï¼šä¿¡æ¯æ˜¾ç¤ºå±‚
      SecondLayer({
        cardData: this.cardData,
        enableWave: this.enableWave,
        cardColors: this.getCardColors(),
        cardNumber: this.getCardNumber(),
        waveHeightPercent: this.getWaveHeightPercent()
      })
      
      // ç¬¬äºŒå±‚å’Œç¬¬ä¸‰å±‚ä¹‹é—´çš„åˆ†éš”çº¿
      Divider()
        .strokeWidth(1)
        .color(this.getCardColors().cardBorder)
        .opacity(0.8)
      
      // ç¬¬ä¸‰å±‚ï¼šæ³¢å½¢å›¾å±‚ï¼ˆæ”¯æŒæ‹–æ‹½æŠ•æ”¾ï¼‰
      ThirdLayer({
        cardData: this.cardData,
        enableWave: this.enableWave,
        localChartData: this.localChartData,
        localChartDataStrings: this.localChartDataStrings,
        hasOriginalFormatData: this.hasOriginalFormatData,
        pendingDragValue: this.pendingDragValue,
        pendingDragIndex: this.pendingDragIndex,
        cardColors: this.getCardColors(),
        waveHeightPercent: this.getWaveHeightPercent(),
        waveBaselinePercent: this.getWaveBaselinePercent(),
        cardNumber: this.getCardNumber(),
        onCachePending: (value: string, index: number) => {
          // åŒæ­¥å­ç»„ä»¶çš„æ‹–æ‹½ç¼“å­˜åˆ°çˆ¶ç»„ä»¶ï¼Œç¡®ä¿åˆ é™¤é€»è¾‘å¯å‘½ä¸­
          this.pendingDragValue = value
          this.pendingDragIndex = index
        },
        onDropCallback: (event, params) => this.handleThirdLayerDrop(event, params),
        onDragEnterCallback: () => { this.isHovering = true },
        onDragLeaveCallback: () => { this.isHovering = false },
        onTouchCallback: () => {
          // æ£€æŸ¥æ˜¯å¦æœ‰Gridæ‹–æ‹½æ•°æ®
          const gridDragData = this.getCurrentGridDragData()
          if (gridDragData) {
            console.log('ç¬¬ä¸‰å±‚æ¥æ”¶åˆ°Gridæ‹–æ‹½æ•°æ®:', gridDragData)
            this.handleGridDragDrop(gridDragData)
          }
        },
        onClickCallback: () => {
          // ç‚¹å‡»ç¬¬ä¸‰å±‚æ—¶é€šçŸ¥çˆ¶ç»„ä»¶
          console.log('ç¬¬ä¸‰å±‚è¢«ç‚¹å‡»ï¼Œé€šçŸ¥çˆ¶ç»„ä»¶æ˜¾ç¤ºè¯¦æƒ…å¯¹è¯æ¡†')
          if (this.onThirdLayerClick) {
            this.onThirdLayerClick()
          }
        },
        deleteItemFromThirdLayer: () => this.deleteItemFromThirdLayer()
      })
    }
    .width(this.cardWidth)
    .height(this.cardHeight)
    .backgroundColor(this.isEmptyCard() ? '#f8fafc' : '#E6F0FF') // ç©ºç™½å¡ç‰‡ï¼šæµ…è‰²èƒŒæ™¯(#f8fafc)ï¼›æœ‰æ•°æ®çš„å¡ç‰‡ï¼šæŸ”å’Œçš„æ·±è“è‰²èƒŒæ™¯(#E6F0FF)
    .borderRadius(12) // Appleé£æ ¼ï¼šä¸­ç­‰åœ†è§’
    .border({ width: 0.5, color: UseCardLogic.getCardColors().cardBorder }) // Appleé£æ ¼ï¼šç»†è¾¹æ¡†
    .shadow({ radius: 8, color: 'rgba(0, 0, 0, 0.1)', offsetX: 0, offsetY: 2 }) // Appleé£æ ¼ï¼šæŸ”å’Œé˜´å½±
    .clip(true) // è£å‰ªå­ç»„ä»¶
    .onMouse((event?: CardMouseEvent) => {
      this.handleMouseEvent(event)
    })
    .onClick(() => {
      this.showContextMenu = false
      this.onCardDrop?.(this.cardData)
    })
    .bindContextMenu(this.showContextMenu, this.buildContextMenu, {
      placement: Placement.Right
    })
    // å¤§å¡ç‰‡å¤–å±‚ï¼šè½åœ¨å¡ç‰‡å®¹å™¨ï¼ˆç¬¬ä¸€/ç¬¬äºŒå±‚æˆ–å¡ç‰‡è¾¹å†…ç©ºç™½ï¼‰è§†ä¸º"å†…å®¹ä¸å˜"
    .onDrop((event: DragEvent, extraParams: string) => {
      UseDragDrop.handleOuterDrop(extraParams)
      // å¤–å±‚å®¹å™¨ä¸æ”¹å˜ handled æ ‡å¿—ï¼Œé¿å…è¦†ç›–çœŸå®ç›®æ ‡å±‚çš„å¤„ç†ç»“æœ
    })
  }
  
  /**
   * æ„å»ºæ‹–æ‹½é¢„è§ˆ
   */
  @Builder
  private buildDragPreview(value: number) {
    Text(`${value}`)
      .fontSize(12)
      .fontWeight(FontWeight.Medium)
      .fontColor(Color.White)
      .backgroundColor(this.mainColor)
      .padding({ left: 8, right: 8, top: 4, bottom: 4 })
      .borderRadius(4)
  }
}
