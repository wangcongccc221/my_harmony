/**
 * æ‹–æ‹½é€»è¾‘ Hookï¼ˆéª¨æ¶ï¼‰
 * åç»­å°†æŠŠ ThreeLayerCard ä¸­çš„æ‹–æ‹½å¤„ç†é€æ­¥è¿ç§»è‡³æ­¤ï¼Œé™ä½ä¸»ç»„ä»¶å¤æ‚åº¦
 */

import { ThreeLayerCardData, FirstLayerData, SecondLayerData, ThirdLayerData, FirstLayerDataInterface, SecondLayerDataInterface, ThirdLayerDataInterface, MultiSelectCell, SystemWrapper, DragOuterPayload, LoosePayload } from '../types'
import { UseCardLogic } from './useCardLogic'
import { UseDataSync, SyncState } from './useDataSync'
import { UseCardState, LocalDataState } from './useCardState'
import { UseDragHandlers } from './useDragHandlers'
import { StorageKeys } from '../../../utils/constants/StorageKeys'

interface OuterSummary {
  value?: string | number
  values?: string[]
}

// LocalDataState ç±»å‹æ¥è‡ª UseCardState

export class UseDragDrop {
  /**
   * å¤šé€‰ï¼šæ›´æ–°å‡ºå£ç­‰çº§æ˜ å°„å¹¶æŒ‰ç­‰çº§å»é‡åæ‰¹é‡ä¸ŠæŠ¥
   */
  static updateLevelMapping(cardId: string, cells: MultiSelectCell[], levelNames?: string[], getCardNumber?: () => number): void {
    try {
      const hasLvns = Array.isArray(levelNames) && levelNames.length === cells.length
      if (hasLvns) {
        const mapRaw = AppStorage.get(StorageKeys.CARD_ITEM_LEVEL_MAP) as Record<string, Record<string, string>> | null
        const mapObj: Record<string, Record<string, string>> = mapRaw ? mapRaw : {}
        if (!mapObj[cardId]) { mapObj[cardId] = {} }
        for (let i = 0; i < cells.length; i++) {
          const valStr = String(cells[i]?.value ?? '')
          const ln = String(levelNames![i] ?? '')
          if (valStr && ln) { mapObj[cardId][valStr] = ln }
        }
        AppStorage.setOrCreate(StorageKeys.CARD_ITEM_LEVEL_MAP, mapObj)
      }

      const collected: string[] = Array.isArray(levelNames) ? levelNames : cells.map((_c: MultiSelectCell) => '')
      const uniqueLevels = Array.from(new Set(collected)).filter(s => s && s.length > 0)
      if (uniqueLevels.length > 0 && typeof getCardNumber === 'function') {
        AppStorage.setOrCreate(StorageKeys.LEVEL_STAT_UPDATE_BATCH, { levelNames: uniqueLevels, exit: Number(getCardNumber()) })
      }
    } catch (_e) {}
  }

  /**
   * å¤„ç†ç­‰çº§ç»Ÿè®¡ï¼šæ›´æ–°æ˜ å°„å¹¶æŒ‰å”¯ä¸€ç­‰çº§åæ‰¹é‡ä¸ŠæŠ¥
   */
  static processLevelStatistics(
    cardData: ThreeLayerCardData,
    cells: MultiSelectCell[],
    levelNames?: string[],
    getCardNumber?: () => number
  ): void {
    try {
      const sourceIsLevelTable = String(cells[0]?.sourceTable || '') === 'ç­‰çº§è¡¨'
      if (!sourceIsLevelTable) { return }
      UseDragDrop.updateLevelMapping(String(cardData.id || ''), cells, levelNames, getCardNumber)
    } catch (_e) {
      console.warn('å¤„ç†ç­‰çº§ç»Ÿè®¡æ—¶å‘ç”Ÿé”™è¯¯:', _e)
    }
  }

  private static getUniqueLevels(levelNames?: string[], cells?: MultiSelectCell[]): string[] {
    let collected: string[] = Array.isArray(levelNames) ? levelNames : []
    if (!Array.isArray(levelNames) || levelNames.length === 0) {
      collected = (cells || []).map((_c: MultiSelectCell) => '')
    }
    return Array.from(new Set(collected)).filter(s => s && s.length > 0)
  }
  /**
   * ç»Ÿä¸€è§£æ extraParamsï¼Œè¿”å› LoosePayload
   */
  static parseDragData(extraParams: string): LoosePayload {
    let payloadStr = extraParams
    if (extraParams && extraParams.indexOf('"extraInfo"') >= 0) {
      const wrapper: SystemWrapper = JSON.parse(extraParams) as SystemWrapper
      payloadStr = String(wrapper.extraInfo ?? extraParams)
    }
    
    let parsed: LoosePayload
    try {
      parsed = JSON.parse(payloadStr) as LoosePayload
    } catch (error) {
      console.error('è§£ææ‹–æ‹½æ•°æ®å¤±è´¥:', error, 'åŸå§‹æ•°æ®:', payloadStr)
      return { type: 'error', value: payloadStr }
    }
    
    // å¤„ç†å¤šé€‰æ‹–æ‹½æ•°æ®ï¼ˆæ¥è‡ª GridTable çš„å¤šé€‰æ‹–æ‹½ï¼‰
    if (parsed.type === 'multi_select' && parsed.values && Array.isArray(parsed.values)) {
      console.log('ğŸ¯ æ£€æµ‹åˆ°å¤šé€‰æ‹–æ‹½æ•°æ®:', parsed.values.length, 'ä¸ªå€¼')
      
      // æ•°æ®å·²ç»åœ¨ GridTable ä¸­ä¼˜åŒ–è¿‡äº†ï¼Œç›´æ¥ä½¿ç”¨
      parsed.count = parsed.count || parsed.values.length
      
      console.log('ğŸ¯ å¤šé€‰æ‹–æ‹½è§£æç»“æœ:', {
        values: parsed.values,
        count: parsed.count
      })
    }
    
    // å¤„ç† fullRowData å­—æ®µï¼ˆæ¥è‡ª GridTable çš„æ•´è¡Œæ‹–æ‹½ï¼‰
    if (parsed.fullRowData && !parsed.rowData) {
      try {
        const rowDataArray = JSON.parse(parsed.fullRowData) as string[]
        if (Array.isArray(rowDataArray)) {
          parsed.rowData = rowDataArray
          parsed.type = 'row'
          console.log('ğŸ¯ è§£æ fullRowData:', parsed.fullRowData, 'è½¬æ¢ä¸º rowData:', parsed.rowData)
        }
      } catch (error) {
        console.error('è§£æ fullRowData å¤±è´¥:', error)
      }
    }
    
    // å¤„ç† fullColumnData å­—æ®µï¼ˆæ¥è‡ª GridTable çš„æ•´åˆ—æ‹–æ‹½ï¼‰
    if (parsed.fullColumnData && !parsed.columnData) {
      try {
        const columnDataArray = JSON.parse(parsed.fullColumnData) as string[]
        if (Array.isArray(columnDataArray)) {
          parsed.columnData = columnDataArray
          parsed.type = 'column'
          console.log('ğŸ¯ è§£æ fullColumnData:', parsed.fullColumnData, 'è½¬æ¢ä¸º columnData:', parsed.columnData)
        }
      } catch (error) {
        console.error('è§£æ fullColumnData å¤±è´¥:', error)
      }
    }
    
    return parsed
  }

  /**
   * å¤„ç†å•å…ƒæ ¼æ‹–æ‹½ï¼ˆå ä½ï¼Œåç»­è¿ç§» ThreeLayerCard å†…å®ç°ï¼‰
   */
  static handleCellDragDrop(cardData: ThreeLayerCardData, value: string, sourceTable: string, rowIndex: number, colIndex: number, onCardDrop?: (data: ThreeLayerCardData) => void): void {
    // æ­£ç¡®å¤„ç†ç™¾åˆ†æ¯”ç¬¦å·ï¼Œå»æ‰%åå†è§£ææ•°å­—
    const v: number = Number.parseFloat(value.replace('%', '')) || 0
    const chartData: number[] = [v]
    const chartConfig: Record<string, string | number> = {}
    chartConfig['sourceTable'] = sourceTable || 'ç­‰çº§è¡¨'
    chartConfig['rowIndex'] = rowIndex || 0
    chartConfig['colIndex'] = colIndex || 0

    const firstLayerData: FirstLayerDataInterface = {
      iconText: cardData.firstLayer.iconText,
      title: cardData.firstLayer.title,
      status: cardData.firstLayer.status
    }
    const secondLayerData: SecondLayerDataInterface = {
      serialNumber: cardData.secondLayer.serialNumber,
      percent: cardData.secondLayer.percent,
      value: cardData.secondLayer.value,
      unit: cardData.secondLayer.unit
    }
    const thirdLayerData: ThirdLayerDataInterface = {
      chartType: cardData.thirdLayer.chartType,
      chartData: chartData,
      chartConfig: chartConfig
    }
    const newCardData: ThreeLayerCardData = {
      id: cardData.id,
      firstLayer: firstLayerData as FirstLayerData,
      secondLayer: secondLayerData as SecondLayerData,
      thirdLayer: thirdLayerData as ThirdLayerData
    }
    onCardDrop?.(newCardData)
  }

  /**
   * å¤„ç† Grid æ‹–æ‹½ï¼ˆå ä½ï¼‰
   */
  static handleGridDragDrop(cardData: ThreeLayerCardData, textValue: string, sourceTable: string, rowIndex: number, colIndex: number, onCardDrop?: (data: ThreeLayerCardData) => void): void {
    UseDragDrop.handleCellDragDrop(cardData, textValue, sourceTable, rowIndex, colIndex, onCardDrop)
  }

  /**
   * å¤„ç†å¤šé€‰æ‹–æ‹½ï¼ˆå ä½ï¼Œè¿”å›æ–°çš„æœ¬åœ°æ¸²æŸ“çŠ¶æ€ä¾›ä¸»ç»„ä»¶æ›´æ–°ï¼‰
   */
  static handleMultiSelectDrop(cardData: ThreeLayerCardData, cells: MultiSelectCell[], levelNames?: string[], onCardDrop?: (data: ThreeLayerCardData) => void): LocalDataState {
    const values: number[] = []
    const originalValues: string[] = []
    for (let i = 0; i < cells.length; i++) {
      // æ­£ç¡®å¤„ç†ç™¾åˆ†æ¯”ç¬¦å·ï¼Œå»æ‰%åå†è§£ææ•°å­—
      const cellValue = String(cells[i]?.value ?? '')
      const vv = Number.parseFloat(cellValue.replace('%', '')) || 0
      values.push(vv)
      originalValues.push(cellValue)
    }

    const prevList: number[] = Array.isArray(cardData?.thirdLayer?.chartData) ? [...(cardData.thirdLayer.chartData as number[])] : []
    for (let i = 0; i < values.length; i++) { prevList.push(values[i]) }

    const prevStrings: string[] = Array.isArray(cardData?.thirdLayer?.chartDataStrings)
      ? [...(cardData.thirdLayer.chartDataStrings as string[])]
      : (prevList.length > values.length ? prevList.slice(0, prevList.length - values.length).map(n => String(n)) : [])
    for (let i = 0; i < originalValues.length; i++) { prevStrings.push(originalValues[i]) }

    // ä¿å­˜å­—ç¬¦ä¸²æ•°ç»„ä¾›åç»­æ˜ å°„ä¸åˆ é™¤ä½¿ç”¨
    const thirdLayerData: ThirdLayerDataInterface = {
      chartType: cardData.thirdLayer.chartType,
      chartData: prevList,
      chartDataStrings: prevStrings,
      chartConfig: cardData.thirdLayer.chartConfig
    }
    const firstLayerData: FirstLayerDataInterface = {
      iconText: cardData.firstLayer.iconText,
      title: cardData.firstLayer.title,
      status: cardData.firstLayer.status
    }
    const secondLayerData: SecondLayerDataInterface = {
      serialNumber: cardData.secondLayer.serialNumber,
      percent: cardData.secondLayer.percent,
      value: cardData.secondLayer.value,
      unit: cardData.secondLayer.unit
    }
    const newCardData: ThreeLayerCardData = {
      id: cardData.id,
      firstLayer: firstLayerData as FirstLayerData,
      secondLayer: secondLayerData as SecondLayerData,
      thirdLayer: thirdLayerData as ThirdLayerData
    }
    onCardDrop?.(newCardData)

    const hasOriginal: boolean = prevStrings.some(v => v.indexOf('%') >= 0)
    return {
      localChartData: prevList,
      localChartDataStrings: prevStrings,
      hasOriginalFormatData: hasOriginal
    }
  }

  /**
   * å¤„ç†ç¬¬ä¸‰å±‚ onDropï¼ˆå•æ¡ä¸å¤šé€‰åˆå¹¶å…¥å£ï¼‰ï¼Œè¿”å›æ–°çš„æœ¬åœ°æ¸²æŸ“çŠ¶æ€
   */
  static handleThirdLayerDrop(
    extraParams: string,
    cardData: ThreeLayerCardData,
    currentState: LocalDataState,
    onCardDrop?: (data: ThreeLayerCardData) => void,
    getCardNumber?: () => number
  ): LocalDataState {
    const dragData = UseDragDrop.parseDragData(extraParams)
    
    // æ•´åˆ—æ‹–æ‹½ï¼šcolumnData æ ¼å¼
    if (dragData.type === 'column' && Array.isArray(dragData.columnData)) {
      console.log('ğŸ¯ å¤„ç†æ•´åˆ—æ‹–æ‹½:', dragData.columnHeader, 'æ•°æ®:', dragData.columnData)
      const columnCells: MultiSelectCell[] = dragData.columnData.map((value: string, index: number): MultiSelectCell => ({
        rowIndex: index,
        colIndex: dragData.columnIndex || 0,
        value: value,
        sourceTable: dragData.sourceTable || 'ç­‰çº§è¡¨',
        cellId: `column_${dragData.columnIndex}_${index}`
      }))
      const state = UseDragDrop.handleMultiSelectDrop(cardData, columnCells, undefined, onCardDrop)
      
      // ä»ç­‰çº§è¡¨æ‹–æ‹½æ•´åˆ—æ—¶ï¼Œéœ€è¦è§¦å‘å‡ºå£è”åŠ¨
      if (dragData.sourceTable === 'ç­‰çº§è¡¨') {
        // ä½¿ç”¨ä¼ é€’è¿‡æ¥çš„ç­‰çº§åç§°æ•°ç»„
        const levelNames = Array.isArray(dragData.levelNames) ? dragData.levelNames : []
        console.log('ğŸ¯ æ•´åˆ—æ‹–æ‹½ç­‰çº§åç§°æ•°ç»„:', levelNames)
        UseDragDrop.updateLevelMapping(String(cardData.id || ''), columnCells, levelNames, getCardNumber)
      } else {
        UseDragDrop.updateLevelMapping(String(cardData.id || ''), columnCells, undefined, getCardNumber)
      }
      return state
    }
    
    // æ•´è¡Œæ‹–æ‹½ï¼šrowData æ ¼å¼
    if (dragData.type === 'row' && Array.isArray(dragData.rowData)) {
      console.log('ğŸ¯ å¤„ç†æ•´è¡Œæ‹–æ‹½:', `ç¬¬${(dragData.rowIndex || 0) + 1}è¡Œ`, 'æ•°æ®:', dragData.rowData, 'å‡ºå£:', dragData.outletInfo)
      const rowCells: MultiSelectCell[] = dragData.rowData.map((value: string, index: number): MultiSelectCell => ({
        rowIndex: dragData.rowIndex || 0,
        colIndex: index,
        value: value,
        sourceTable: dragData.sourceTable || 'ç­‰çº§è¡¨',
        cellId: `row_${dragData.rowIndex}_${index}`
      }))
      
      // å¦‚æœæœ‰å‡ºå£ä¿¡æ¯ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†
      if (dragData.outletInfo && dragData.sourceTable === 'ç­‰çº§ç»Ÿè®¡è¡¨') {
        console.log('ğŸ¯ ç­‰çº§ç»Ÿè®¡è¡¨æ‹–æ‹½ï¼Œå‡ºå£ä¿¡æ¯:', dragData.outletInfo)
        // ä»å‡ºå£ä¿¡æ¯ä¸­æå–å‡ºå£ç¼–å·
        const outletMatch = dragData.outletInfo.match(/å‡ºå£(\d+)/)
        if (outletMatch) {
          const outletNumber = parseInt(outletMatch[1])
          console.log('ğŸ¯ æå–åˆ°å‡ºå£ç¼–å·:', outletNumber)
          
          // ä»rowDataä¸­æå–ç­‰çº§åç§°ï¼ˆç¬¬ä¸€ä¸ªå…ƒç´ ï¼‰
          const levelName = dragData.rowData[0] || ''
          console.log('ğŸ¯ æå–åˆ°ç­‰çº§åç§°:', levelName)
          
          // ä¸ºæ¯ä¸ªcellåˆ›å»ºå¯¹åº”çš„ç­‰çº§åç§°æ•°ç»„
          const levelNames = rowCells.map(() => levelName)
          console.log('ğŸ¯ ç­‰çº§åç§°æ•°ç»„:', levelNames)
          
          // æ›´æ–°ç­‰çº§æ˜ å°„ï¼Œä½¿ç”¨å‡ºå£ç¼–å·å’Œç­‰çº§åç§°
          UseDragDrop.updateLevelMapping(String(cardData.id || ''), rowCells, levelNames, () => outletNumber)
        }
      }
      
      const state = UseDragDrop.handleMultiSelectDrop(cardData, rowCells, undefined, onCardDrop)
      if (!dragData.outletInfo || dragData.sourceTable !== 'ç­‰çº§ç»Ÿè®¡è¡¨') {
        // ä»ç­‰çº§è¡¨æ‹–æ‹½æ•´è¡Œæ—¶ï¼Œéœ€è¦è§¦å‘å‡ºå£è”åŠ¨
        if (dragData.sourceTable === 'ç­‰çº§è¡¨') {
          // ä½¿ç”¨ä¼ é€’è¿‡æ¥çš„ç­‰çº§åç§°
          const levelName: string = String(dragData.levelName || '')
          console.log('ğŸ¯ æ•´è¡Œæ‹–æ‹½ç­‰çº§åç§°:', levelName)
          // ä¸ºæ¯ä¸ªcellåˆ›å»ºå¯¹åº”çš„ç­‰çº§åç§°æ•°ç»„
          const levelNames: string[] = rowCells.map((): string => levelName)
          UseDragDrop.updateLevelMapping(String(cardData.id || ''), rowCells, levelNames, getCardNumber)
        } else {
          UseDragDrop.updateLevelMapping(String(cardData.id || ''), rowCells, undefined, getCardNumber)
        }
      }
      return state
    }
    
    // å¤šé€‰ï¼šcells å®Œæ•´æ ¼å¼
    if (Array.isArray(dragData.cells)) {
      const cells = dragData.cells as MultiSelectCell[]
      const lvns: string[] | undefined = Array.isArray(dragData.levelNames) ? (dragData.levelNames as string[]) : undefined
      const state = UseDragDrop.handleMultiSelectDrop(cardData, cells, lvns, onCardDrop)
      UseDragDrop.updateLevelMapping(String(cardData.id || ''), cells, lvns, getCardNumber)
      return state
    }
    // å¤šé€‰ï¼švalues ç®€åŒ–æ ¼å¼
    if (Array.isArray(dragData.values)) {
      const valuesArr = dragData.values as string[]
      const simplifiedCells: MultiSelectCell[] = valuesArr.map((value: string, index: number): MultiSelectCell => ({
        rowIndex: 0,
        colIndex: index,
        value: value,
        sourceTable: 'ç­‰çº§è¡¨',
        cellId: `simplified_${index}`
      }))
      const lvns: string[] | undefined = Array.isArray(dragData.levelNames) ? (dragData.levelNames as string[]) : undefined
      const state = UseDragDrop.handleMultiSelectDrop(cardData, simplifiedCells, lvns, onCardDrop)
      UseDragDrop.updateLevelMapping(String(cardData.id || ''), simplifiedCells, lvns, getCardNumber)
      return state
    }

    // å•æ¡
    const parsedRes = UseDragHandlers.parseDrop(extraParams)
    const valueStr: string = parsedRes ? parsedRes.valueStr : String((dragData as Record<string, string | number>)['value'] ?? '')
    const originalValue: string = parsedRes ? parsedRes.originalValue : String((dragData as Record<string, string | number>)['sourceValue'] ?? (dragData as Record<string, string | number>)['originalValue'] ?? valueStr)
    const sourceTable: string = parsedRes ? parsedRes.sourceTable : String((dragData as Record<string, string | number>)['sourceTable'] ?? 'ç­‰çº§è¡¨')
    const rowIndex: number = Number((dragData as Record<string, string | number>)['rowIndex'] ?? 0)
    const colIndex: number = Number((dragData as Record<string, string | number>)['colIndex'] ?? 0)
    const sourceCardId: string = parsedRes ? parsedRes.sourceCardId : String((dragData as Record<string, string | number>)['sourceCardId'] ?? '')
    const dragSession: string = parsedRes ? parsedRes.dragSession : String((dragData as Record<string, string | number>)['dragSession'] ?? '')

    const isFromCard: boolean = UseDragHandlers.isFromCard(sourceTable, sourceCardId, String(cardData.id || ''))
    const isFromTable: boolean = (sourceTable === 'ç­‰çº§è¡¨' || sourceTable === 'card_third_layer')
    if (isFromCard) {
      UseDragHandlers.markDropHandled()
      if (dragSession) {
        try { AppStorage.setOrCreate(StorageKeys.CARD_DRAG_HANDLED_SESSION, dragSession) } catch (_e) {}
      }
      AppStorage.set(StorageKeys.REMOVE_SOURCE_DATA, {
        sourceCardId: sourceCardId,
        sourceValue: originalValue
      })
    } else if (isFromTable) {
      UseDragHandlers.markDropHandled()
      if (dragSession) {
        try { AppStorage.setOrCreate(StorageKeys.CARD_DRAG_HANDLED_SESSION, dragSession) } catch (_e) {}
      }
    } else {
      UseDragHandlers.markDropUnhandled()
    }

    const v: number = Number.parseFloat(valueStr) || 0
    const localList: number[] = UseCardLogic.safeSlice(currentState.localChartData)
    const localStringList: string[] = UseCardLogic.safeSlice(currentState.localChartDataStrings)
    localList.push(v)
    localStringList.push(originalValue)

    const nextState: LocalDataState = {
      localChartData: localList,
      localChartDataStrings: localStringList,
      hasOriginalFormatData: currentState.hasOriginalFormatData || originalValue.indexOf('%') >= 0
    }
    UseDataSync.updateCardData(cardData, nextState.localChartData, nextState.localChartDataStrings, onCardDrop)

    // å»ºç«‹/è¿ç§»æ˜ å°„ä¸ç»Ÿè®¡
    try {
      if (sourceTable === 'ç­‰çº§è¡¨') {
        const levelNameFromPayload: string = String((dragData as Record<string, string | number>)['levelName'] || '')
        if (levelNameFromPayload) {
          const cardNum: number = typeof getCardNumber === 'function' ? Number(getCardNumber()) : 0
          const cardId = String(cardData.id || '')
          UseDragHandlers.mapValueToLevel(cardId, originalValue, levelNameFromPayload, cardNum)
        }
      }
      if (sourceTable === 'card_third_layer') {
        const fromCardId: string = String((dragData as Record<string, string | number>)['sourceCardId'] || '')
        const valStr: string = String((dragData as Record<string, string | number>)['sourceValue'] || '')
        const levelName: string = String((dragData as Record<string, string | number>)['levelName'] || '')
        const toExit = typeof getCardNumber === 'function' ? Number(getCardNumber()) : 0
        const toCardId = String(cardData.id || '')
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯ä»åŒä¸€ä¸ªå¡ç‰‡æ‹–æ‹½ï¼ˆä¸åº”è¯¥è§¦å‘ç§»åŠ¨é€»è¾‘ï¼‰
        if (fromCardId === toCardId) {
          console.log('ğŸ¯ åŒå¡ç‰‡å†…æ‹–æ‹½ï¼Œè·³è¿‡ç§»åŠ¨é€»è¾‘')
          return nextState
        }
        
        // å¦‚æœæœ‰ç­‰çº§åç§°ï¼Œç›´æ¥ä½¿ç”¨ç­‰çº§åç§°è¿›è¡Œè¿½åŠ 
        if (levelName) {
          console.log(`ğŸ¯ å¡ç‰‡é—´æ‹–æ‹½ï¼Œä½¿ç”¨ç­‰çº§åç§°: ${levelName}`)
          UseDragHandlers.mapValueToLevel(toCardId, valStr, levelName, toExit)
        } else {
          // ä½¿ç”¨è¿½åŠ é€»è¾‘è€Œä¸æ˜¯ç§»åŠ¨é€»è¾‘ï¼Œè¿™æ ·ä¸ä¼šåˆ é™¤åŸæ¥çš„æ˜ å°„
          UseDragHandlers.appendMappingToCard(fromCardId, valStr, toCardId, toExit)
        }
      }
    } catch (_e) {}

    return nextState
  }

  /**
   * å¤–å±‚å¡ç‰‡ onDrop è®°å½•æ‘˜è¦ï¼ˆä¸æ”¹ handled æ ‡è®°ï¼‰
   */
  static handleOuterDrop(extraParams: string): void {
    let raw = extraParams
    try {
      if (raw && raw.indexOf('"extraInfo"') >= 0) {
        const wrapper: SystemWrapper = JSON.parse(raw) as SystemWrapper
        raw = String(wrapper.extraInfo ?? raw)
      }
      const outer: OuterSummary = JSON.parse(raw) as OuterSummary
      const hasDirectValue: boolean = (typeof outer.value === 'string' || typeof outer.value === 'number')
      const hasValuesArray: boolean = Array.isArray(outer.values)
      const valueStr: string = hasDirectValue ? String(outer.value as string | number) : (hasValuesArray ? 'values[]' : '')
      console.log('ğŸŸ¢ å†…å®¹ä¸å˜ ç§»åŠ¨å†…å®¹:', valueStr)
    } catch (_e) {
      console.log('ğŸŸ¢ å†…å®¹ä¸å˜ ç§»åŠ¨å†…å®¹:', raw)
    }
  }
}
