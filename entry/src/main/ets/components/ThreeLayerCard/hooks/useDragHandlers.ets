/**
 * æ‹–æ‹½å¤„ç† hooksï¼ˆåˆç‰ˆï¼‰
 * - è§£æ Drop è´Ÿè½½
 * - æ ‡è®°æ˜¯å¦å·²å¤„ç†ï¼ˆhandled/unhandledï¼‰
 * - æ¥æºåˆ¤å®šå·¥å…·
 */

import { SystemWrapper, DragOuterPayload } from '../types'
import { StorageKeys } from '../../../utils/constants/StorageKeys'

export interface ParsedDropResult {
  valueStr: string
  originalValue: string
  sourceTable: string
  sourceCardId: string
}

export class UseDragHandlers {
  static parseDrop(extraParams: string): ParsedDropResult | null {
    if (!extraParams || extraParams.length === 0) { return null }
    try {
      let payload = extraParams
      if (extraParams.includes('"extraInfo"')) {
        const wrapper: SystemWrapper = JSON.parse(extraParams) as SystemWrapper
        payload = String(wrapper.extraInfo ?? extraParams)
      }
      const parsed: Record<string, string | number> = JSON.parse(payload)
      const valueStr: string = String(parsed['value'] ?? '')
      const originalValue: string = String(parsed['sourceValue'] ?? parsed['originalValue'] ?? valueStr)
      const sourceTable: string = String(parsed['sourceTable'] ?? 'ç­‰çº§è¡¨')
      const sourceCardId: string = String(parsed['sourceCardId'] ?? '')
      // ä»…ä¿ç•™å…³é”®é“¾è·¯ï¼šonDrop è§£ææ‘˜è¦
      console.log('ğŸ§© Dropè§£æ: value=', valueStr, 'original=', originalValue, 'from=', sourceTable, 'sourceCardId=', sourceCardId)
      return { valueStr, originalValue, sourceTable, sourceCardId }
    } catch (_e) {
      return null
    }
  }

  static markDropHandled(): void {
    AppStorage.set(StorageKeys.GLOBAL_DROP_HANDLED, true)
  }

  static markDropUnhandled(): void {
    AppStorage.set(StorageKeys.GLOBAL_DROP_HANDLED, false)
  }

  static isFromCard(sourceTable: string, sourceCardId: string, targetCardId: string): boolean {
    return (
      !!sourceCardId && String(sourceCardId) !== String(targetCardId)
    ) || (sourceTable === 'card_third_layer' && String(sourceCardId) !== String(targetCardId))
  }

  /**
   * æ ¹æ® cardId ä¸åŸå§‹å€¼(valStr)ç§»é™¤æ˜ å°„ï¼Œå¹¶ä¸ŠæŠ¥ç­‰çº§å‡ºå£ç§»é™¤äº‹ä»¶
   */
  static emitRemoveLevelExit(cardId: string, valStr: string, exitNum: number): void {
    try {
      const mapRaw = AppStorage.get('CARD_ITEM_LEVEL_MAP') as Record<string, Record<string, string>> | null
      const mapObj: Record<string, Record<string, string>> = mapRaw ? mapRaw : {}
      const levelName = (mapObj[cardId] && mapObj[cardId][valStr]) ? mapObj[cardId][valStr] : ''
      if (levelName) {
        // æ£€æŸ¥è¯¥å¡ç‰‡æ˜¯å¦è¿˜æœ‰å…¶ä»–ç›¸åŒç­‰çº§çš„å…ƒç´ 
        const cardMappings = mapObj[cardId] || {}
        const sameLevelItems = Object.keys(cardMappings).filter(key => 
          key !== valStr && cardMappings[key] === levelName
        )
        
        console.log(`ğŸ” æ£€æŸ¥å¡ç‰‡${cardId}ä¸­ç­‰çº§${levelName}çš„å…¶ä»–å…ƒç´ :`, sameLevelItems)
        
        // å¦‚æœè¯¥å¡ç‰‡æ²¡æœ‰å…¶ä»–ç›¸åŒç­‰çº§çš„å…ƒç´ ï¼Œåˆ é™¤å‡ºå£æ˜ å°„
        if (sameLevelItems.length === 0) {
          console.log(`âŒ å¡ç‰‡${cardId}ä¸­æ²¡æœ‰å…¶ä»–${levelName}å…ƒç´ ï¼Œåˆ é™¤å‡ºå£æ˜ å°„`)
          AppStorage.setOrCreate('LEVEL_STAT_REMOVE', { levelName: levelName, exit: exitNum })
        } else {
          console.log(`âœ… å¡ç‰‡${cardId}ä¸­è¿˜æœ‰${sameLevelItems.length}ä¸ª${levelName}å…ƒç´ ï¼Œä¸åˆ é™¤å‡ºå£æ˜ å°„`)
        }
        
        // åˆ é™¤å½“å‰å…ƒç´ çš„æ˜ å°„
        mapObj[cardId][valStr] = ''
        const cleaned: Record<string, Record<string, string>> = {}
        Object.keys(mapObj).forEach(cid => {
          const inner = mapObj[cid]
          const nextInner: Record<string, string> = {}
          Object.keys(inner).forEach(k => {
            const v = inner[k]
            if (v && v.length > 0) { nextInner[k] = v }
          })
          cleaned[cid] = nextInner
        })
        AppStorage.setOrCreate('CARD_ITEM_LEVEL_MAP', cleaned)
        console.log(`ğŸ—‘ï¸ åˆ é™¤å…ƒç´ æ˜ å°„: ç­‰çº§=${levelName}, å‡ºå£=${exitNum}, key=${valStr}`)
      }
    } catch (_e) {}
  }

  // é™åˆ¶æ¯ä¸ªå¡ç‰‡çš„æœ€å¤§æ˜ å°„æ•°é‡ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
  private static readonly MAX_MAPPINGS_PER_CARD: number = 1000
  // é™åˆ¶æ€»å¡ç‰‡æ•°é‡ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
  private static readonly MAX_CARDS: number = 50

  /**
   * é™åˆ¶æ˜ å°„å¯¹è±¡å¤§å°ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
   */
  private static limitMapSize(mapObj: Record<string, Record<string, string>>): Record<string, Record<string, string>> {
    const cardIds = Object.keys(mapObj)
    
    // å¦‚æœå¡ç‰‡æ•°é‡è¶…è¿‡é™åˆ¶ï¼Œåªä¿ç•™æœ€æ–°çš„å¡ç‰‡
    if (cardIds.length > UseDragHandlers.MAX_CARDS) {
      const limited: Record<string, Record<string, string>> = {}
      // ä¿ç•™æœ€å MAX_CARDS ä¸ªå¡ç‰‡
      const keepCards = cardIds.slice(-UseDragHandlers.MAX_CARDS)
      keepCards.forEach(cardId => {
        limited[cardId] = mapObj[cardId]
      })
      console.warn(`âš ï¸ CARD_ITEM_LEVEL_MAP å¡ç‰‡æ•°é‡è¶…è¿‡é™åˆ¶ï¼Œå·²æ¸…ç†æ—§æ•°æ®: ${cardIds.length} -> ${keepCards.length}`)
      return limited
    }
    
    // é™åˆ¶æ¯ä¸ªå¡ç‰‡çš„æ˜ å°„æ•°é‡
    const limited: Record<string, Record<string, string>> = {}
    cardIds.forEach(cardId => {
      const cardMap = mapObj[cardId]
      const keys = Object.keys(cardMap)
      if (keys.length > UseDragHandlers.MAX_MAPPINGS_PER_CARD) {
        // åªä¿ç•™æœ€æ–°çš„æ˜ å°„
        const keepKeys = keys.slice(-UseDragHandlers.MAX_MAPPINGS_PER_CARD)
        limited[cardId] = {}
        keepKeys.forEach(key => {
          limited[cardId][key] = cardMap[key]
        })
        console.warn(`âš ï¸ å¡ç‰‡ ${cardId} æ˜ å°„æ•°é‡è¶…è¿‡é™åˆ¶ï¼Œå·²æ¸…ç†æ—§æ•°æ®: ${keys.length} -> ${keepKeys.length}`)
      } else {
        limited[cardId] = cardMap
      }
    })
    
    return limited
  }

  /**
   * ä¸ºå½“å‰å¡ç‰‡å»ºç«‹ å€¼->ç­‰çº§ çš„æ˜ å°„ï¼Œå¹¶ä¸ŠæŠ¥"æ–°å¢å‡ºå£"äº‹ä»¶
   */
  static mapValueToLevel(cardId: string, originalValue: string, levelName: string, exitNum: number): void {
    try {
      console.log(`ğŸ”„ mapValueToLevel è¢«è°ƒç”¨: cardId=${cardId}, originalValue=${originalValue}, levelName=${levelName}, exitNum=${exitNum}`)
      const mapRaw = AppStorage.get('CARD_ITEM_LEVEL_MAP') as Record<string, Record<string, string>> | null
      let mapObj: Record<string, Record<string, string>> = mapRaw ? mapRaw : {}
      
      // é™åˆ¶æ˜ å°„å¤§å°ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
      mapObj = UseDragHandlers.limitMapSize(mapObj)
      
      if (!mapObj[cardId]) { mapObj[cardId] = {} }
      if (originalValue) {
        mapObj[cardId][originalValue] = levelName
        // å†æ¬¡é™åˆ¶å¤§å°ï¼ˆæ·»åŠ åå¯èƒ½è¶…è¿‡é™åˆ¶ï¼‰
        mapObj = UseDragHandlers.limitMapSize(mapObj)
        AppStorage.setOrCreate('CARD_ITEM_LEVEL_MAP', mapObj)
      }
      if (levelName && exitNum > 0) {
        console.log(`ğŸš€ è§¦å‘ LEVEL_STAT_UPDATE äº‹ä»¶: { levelName: "${levelName}", exit: ${exitNum} }`)
        AppStorage.setOrCreate('LEVEL_STAT_UPDATE', { levelName: levelName, exit: exitNum })
      }
      console.log(`â• æ˜ å°„æ–°å¢: ç­‰çº§=${levelName}, å‡ºå£=${exitNum}, key=${originalValue}`)
    } catch (_e) {
      console.error(`âŒ mapValueToLevel å‘ç”Ÿé”™è¯¯:`, _e)
    }
  }

  /**
   * è¿½åŠ æ˜ å°„åˆ°ç›®æ ‡å¡ç‰‡ï¼šåªæ·»åŠ æ–°æ˜ å°„ï¼Œä¸åˆ é™¤åŸæ˜ å°„ï¼Œç”¨äºå•ä¸ªå…ƒç´ æ‹–æ‹½
   */
  static appendMappingToCard(fromCardId: string, valStr: string, toCardId: string, toExit: number): void {
    try {
      const mapRaw = AppStorage.get('CARD_ITEM_LEVEL_MAP') as Record<string, Record<string, string>> | null
      let mapObj: Record<string, Record<string, string>> = mapRaw ? mapRaw : {}
      
      // é™åˆ¶æ˜ å°„å¤§å°ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
      mapObj = UseDragHandlers.limitMapSize(mapObj)
      
      const levelName = (mapObj[fromCardId] && mapObj[fromCardId][valStr]) ? mapObj[fromCardId][valStr] : ''
      if (!levelName) { return }
      
      // åªæ·»åŠ æ–°æ˜ å°„ï¼Œä¸åˆ é™¤åŸæ˜ å°„
      if (toExit > 0) {
        console.log(`ğŸš€ è§¦å‘ LEVEL_STAT_UPDATE äº‹ä»¶ï¼ˆè¿½åŠ ï¼‰: { levelName: "${levelName}", exit: ${toExit} }`)
        AppStorage.setOrCreate('LEVEL_STAT_UPDATE', { levelName: levelName, exit: toExit })
      }
      
      // æ›´æ–°æ˜ å°„å…³ç³»
      if (!mapObj[toCardId]) { mapObj[toCardId] = {} }
      mapObj[toCardId][valStr] = levelName
      // å†æ¬¡é™åˆ¶å¤§å°ï¼ˆæ·»åŠ åå¯èƒ½è¶…è¿‡é™åˆ¶ï¼‰
      mapObj = UseDragHandlers.limitMapSize(mapObj)
      AppStorage.setOrCreate('CARD_ITEM_LEVEL_MAP', mapObj)
      
      console.log(`â• æ˜ å°„è¿½åŠ : ç­‰çº§=${levelName}, å‡ºå£=${toExit}, key=${valStr}`)
    } catch (_e) {
      console.error(`âŒ appendMappingToCard å‘ç”Ÿé”™è¯¯:`, _e)
    }
  }

  /**
   * åœ¨å¡ç‰‡é—´ç§»åŠ¨æ˜ å°„ï¼šä» fromCardId ç§»é™¤ï¼Œå†æ·»åŠ è‡³ toCardIdï¼Œå¹¶ä¸ŠæŠ¥"å‡ºå£æ›¿æ¢"
   */
  static moveMappingBetweenCards(fromCardId: string, valStr: string, toCardId: string, toExit: number): void {
    try {
      const mapRaw = AppStorage.get('CARD_ITEM_LEVEL_MAP') as Record<string, Record<string, string>> | null
      const mapObj: Record<string, Record<string, string>> = mapRaw ? mapRaw : {}
      const levelName = (mapObj[fromCardId] && mapObj[fromCardId][valStr]) ? mapObj[fromCardId][valStr] : ''
      if (!levelName) { return }
      const fromExit = ((): number => {
        const m = fromCardId.match(/card_(\d+)/)
        return m && m[1] ? (parseInt(m[1]) + 1) : 0
      })()
      if (fromExit > 0) {
        AppStorage.setOrCreate('LEVEL_STAT_REMOVE', { levelName: levelName, exit: fromExit })
      }
      if (toExit > 0) {
        AppStorage.setOrCreate('LEVEL_STAT_UPDATE', { levelName: levelName, exit: toExit })
      }
      if (!mapObj[toCardId]) { mapObj[toCardId] = {} }
      mapObj[toCardId][valStr] = levelName
      if (mapObj[fromCardId]) {
        mapObj[fromCardId][valStr] = ''
      }
      // æ¸…ç†ç©ºå€¼
      const cleaned: Record<string, Record<string, string>> = {}
      Object.keys(mapObj).forEach(cid => {
        const inner = mapObj[cid]
        const nextInner: Record<string, string> = {}
        Object.keys(inner).forEach(k => {
          const v = inner[k]
          if (v && v.length > 0) { nextInner[k] = v }
        })
        cleaned[cid] = nextInner
      })
      AppStorage.setOrCreate('CARD_ITEM_LEVEL_MAP', cleaned)
      console.log(`ğŸ” æ˜ å°„è¿ç§»: ç­‰çº§=${levelName}, ${fromExit} -> ${toExit}, key=${valStr}`)
    } catch (_e) {}
  }
}


