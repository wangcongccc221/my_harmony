/**
 * Gridè¡¨æ ¼ç»„ä»¶ - æ”¯æŒæ‹–æ‹½åŠŸèƒ½
 * 
 * åŠŸèƒ½è¯´æ˜ï¼š
 * - ä½¿ç”¨Gridç»„ä»¶å®ç°è¡¨æ ¼å¸ƒå±€
 * - æ”¯æŒæ‹–æ‹½äº¤æ¢å•å…ƒæ ¼å†…å®¹
 * - å›ºå®šè¡¨å¤´ï¼Œå¯æ»šåŠ¨æ•°æ®åŒºåŸŸ
 * - å…¼å®¹åŸæœ‰çš„TableRowæ•°æ®ç»“æ„
 * 
 * åŸºäºåä¸ºå®˜æ–¹æœ€ä½³å®è·µï¼š
 * https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-grid-drag-swap
 */

import { OmniThemeManager, ExtendedOmniThemeStyle } from '../../utils/theme/OmniThemeManager'
import { TableRow } from './LevelTable'
import { MultiSelectCell, MultiSelectState } from '../ThreeLayerCard/types'
import { StorageKeys } from '../../utils/constants/StorageKeys'

// æ‹–æ‹½æ•°æ®æ¥å£
interface DragData {
  rowIndex: number
  colIndex: number
  value: string
  sourceTable: string
  fullRowData?: string // å®Œæ•´è¡Œæ•°æ®ï¼ˆç”¨äºæ•´è¡Œæ‹–æ‹½ï¼‰
  fullColumnData?: string // å®Œæ•´åˆ—æ•°æ®ï¼ˆç”¨äºæ•´åˆ—æ‹–æ‹½ï¼‰
  levelName?: string // ç­‰çº§åç§°ï¼ˆç”¨äºç­‰çº§ç»Ÿè®¡è¡¨è”åŠ¨ï¼‰
  levelNames?: string[] // ç­‰çº§åç§°æ•°ç»„ï¼ˆç”¨äºæ•´åˆ—æ‹–æ‹½è”åŠ¨ï¼‰
}

@Component
export struct GridTable {
  // è¡¨æ ¼åå­— - ç”¨äºæ•°æ®ç®¡ç†
  @Prop tableName: string = 'default'
  // æ˜¯å¦å…è®¸æ‹–æ‹½ï¼ˆé»˜è®¤trueï¼Œä¸»é¡µå¯æŒ‰ä¸šåŠ¡å…³é—­ï¼‰
  @Prop enableDrag: boolean = true
  
  // å¤šé€‰çŠ¶æ€ç®¡ç†
  @State private selectedCells: Set<string> = new Set()
  @State private isMultiSelectMode: boolean = false
  
  // è¡¨æ ¼æ•°æ®ï¼ˆäºŒç»´å­—ç¬¦ä¸²ï¼‰
  @Prop tableRows: TableRow[] = [
    ['Açº§', '15', '8', '5', '2'],
    ['Bçº§', '10', '6', '3', '1'],
    ['Cçº§', '5', '6', '2', '0']
  ]
  
  // è¡¨æ ¼æ ‡é¢˜
  @Prop tableTitle: string = 'ç­‰çº§è¡¨'
  
  // è¡¨å¤´æ ‡é¢˜ï¼ˆä¸æ¯è¡Œåˆ—æ•°ä¸€è‡´ï¼‰
  @Prop headerTitles: string[] = ['ç­‰çº§', '30', '20', '10', '0']
  
  // è¡¨æ ¼å®½åº¦
  @Prop tableWidth: string = '55%'
  
  // è¡¨æ ¼æœ€å¤§é«˜åº¦ï¼ˆè¶…è¿‡æ­¤é«˜åº¦å¯æ»šåŠ¨ï¼‰
  @Prop maxHeight: string = '300px'
  
  // å¤–å±‚å®¹å™¨èƒŒæ™¯è‰²ï¼ˆä¸ä¼ åˆ™ä½¿ç”¨ä¸»é¢˜ surfaceColorï¼‰
  @Prop containerBg: string = ''

  // å½“å‰ä¸»é¢˜æ ·å¼
  private currentTheme: ExtendedOmniThemeStyle = OmniThemeManager.getInstance().getCurrentTheme()

  /**
   * è·å–å½“å‰ä¸»é¢˜é…ç½®
   */
  private getCurrentTheme(): ExtendedOmniThemeStyle {
    return this.currentTheme
  }

  /**
   * åˆ‡æ¢å•å…ƒæ ¼é€‰ä¸­çŠ¶æ€
   */
  private toggleCellSelection(rowIndex: number, colIndex: number, cellText: string) {
    if (!this.enableDrag) {
      return
    }
    
    const cellId = `${rowIndex}_${colIndex}`
    
    if (this.selectedCells.has(cellId)) {
      // å–æ¶ˆé€‰ä¸­
      this.selectedCells.delete(cellId)
      console.log('ğŸ”´ GridTable - å–æ¶ˆé€‰ä¸­å•å…ƒæ ¼:', cellText)
    } else {
      // é€‰ä¸­
      this.selectedCells.add(cellId)
      console.log('ğŸŸ¢ GridTable - é€‰ä¸­å•å…ƒæ ¼:', cellText)
    }
    
    // æ›´æ–°å¤šé€‰æ¨¡å¼çŠ¶æ€
    this.isMultiSelectMode = this.selectedCells.size > 1
    
    // æ›´æ–°å…¨å±€å¤šé€‰çŠ¶æ€
    this.updateGlobalMultiSelectState()
    
    console.log('ğŸ“Š GridTable - å½“å‰é€‰ä¸­å•å…ƒæ ¼æ•°é‡:', this.selectedCells.size)
  }

  /**
   * æ›´æ–°å…¨å±€å¤šé€‰çŠ¶æ€
   */
  private updateGlobalMultiSelectState() {
    if (!this.enableDrag) {
      return
    }
    
    const selectedCellsArray: MultiSelectCell[] = []
    
    this.selectedCells.forEach(cellId => {
      const parts = cellId.split('_')
      const rowIndex = Number(parts[0])
      const colIndex = Number(parts[1])
      const cellText = this.tableRows[rowIndex]?.[colIndex] || ''
      
      selectedCellsArray.push({
        rowIndex: rowIndex,
        colIndex: colIndex,
        value: cellText,
        sourceTable: this.tableName,
        cellId: cellId
      })
    })
    
    const multiSelectState: MultiSelectState = {
      cells: selectedCellsArray,
      isActive: selectedCellsArray.length > 0
    }
    
    AppStorage.set(StorageKeys.MULTI_SELECT_CELLS_KEY, multiSelectState)
    AppStorage.set(StorageKeys.MULTI_SELECT_ACTIVE_KEY, multiSelectState.isActive)
    
    console.log('ğŸ”„ GridTable - æ›´æ–°å…¨å±€å¤šé€‰çŠ¶æ€:', JSON.stringify(multiSelectState))
  }

  /**
   * æ¸…é™¤æ‰€æœ‰é€‰ä¸­çŠ¶æ€
   */
  private clearAllSelections() {
    this.selectedCells.clear()
    this.isMultiSelectMode = false
    
    // æ¸…é™¤å…¨å±€å¤šé€‰çŠ¶æ€
    AppStorage.set(StorageKeys.MULTI_SELECT_CELLS_KEY, { cells: [], isActive: false })
    AppStorage.set(StorageKeys.MULTI_SELECT_ACTIVE_KEY, false)
    
    console.log('ğŸ§¹ GridTable - æ¸…é™¤æ‰€æœ‰é€‰ä¸­çŠ¶æ€')
  }

  /**
   * æ£€æŸ¥å•å…ƒæ ¼æ˜¯å¦è¢«é€‰ä¸­
   */
  private isCellSelected(rowIndex: number, colIndex: number): boolean {
    const cellId = `${rowIndex}_${colIndex}`
    return this.selectedCells.has(cellId)
  }

  /**
   * è·å–åˆ—æ¨¡æ¿å­—ç¬¦ä¸²
   * æ ¹æ®è¡¨å¤´æ•°é‡åŠ¨æ€ç”Ÿæˆç­‰å®½åˆ—æ¨¡æ¿
   */
  private getColumnsTemplate(): string {
    const columnCount = this.headerTitles.length
    return Array(columnCount).fill('1fr').join(' ')
  }

  /**
   * å¤„ç†æ‹–æ‹½å¼€å§‹äº‹ä»¶
   * åŸºäºåä¸ºå®˜æ–¹æœ€ä½³å®è·µå®ç°
   */
  private handleDragStart(rowIndex: number, colIndex: number, cellValue: string): DragItemInfo {
    if (!this.enableDrag) {
      return { pixelMap: undefined, builder: undefined, extraInfo: '' }
    }

    // æ£€æŸ¥æ˜¯å¦æœ‰å¤šä¸ªé€‰ä¸­çš„å•å…ƒæ ¼
    if (this.isMultiSelectMode && this.selectedCells.size > 1) {
      // å¤šé€‰æ‹–æ‹½ï¼šä½¿ç”¨æ‰€æœ‰é€‰ä¸­çš„å•å…ƒæ ¼æ•°æ®
      console.log('ğŸ¯ GridTable - å¼€å§‹å¤šé€‰æ‹–æ‹½ï¼Œé€‰ä¸­å•å…ƒæ ¼æ•°é‡:', this.selectedCells.size)
      
      const selectedCellsArray: MultiSelectCell[] = []
      this.selectedCells.forEach(cellId => {
        const parts = cellId.split('_')
        const r = Number(parts[0])
        const c = Number(parts[1])
        const text = this.tableRows[r]?.[c] || ''
        selectedCellsArray.push({
          rowIndex: r,
          colIndex: c,
          value: text,
          sourceTable: this.tableName,
          cellId: cellId
        })
      })
      
      // ä¼˜åŒ–å¤šé€‰æ‹–æ‹½æ•°æ®æ ¼å¼ï¼Œå‡å°‘æ•°æ®é‡
      const values = selectedCellsArray.map(cell => cell.value)
      // æ”¶é›†æ‰€æœ‰æ¶‰åŠçš„ç­‰çº§åç§°ï¼ˆä»ç¬¬ä¸€åˆ—è·å–ï¼‰
      const levelNames = selectedCellsArray.map(cell => this.tableRows[cell.rowIndex]?.[0] || '')
      const dragDataStr = JSON.stringify({
        type: 'multi_select',
        values: values,
        levelNames: levelNames, // æ·»åŠ ç­‰çº§åç§°æ•°ç»„
        count: selectedCellsArray.length
      })
      
      console.log('ğŸ¯ GridTable - å¤šé€‰æ‹–æ‹½æ•°æ®:', dragDataStr)
      
      // æ‹–æ‹½å®Œæˆåæ¸…é™¤é€‰ä¸­çŠ¶æ€
      setTimeout(() => {
        this.clearAllSelections()
      }, 100)
      
      return {
        pixelMap: undefined,
        builder: undefined,
        extraInfo: dragDataStr
      }
    } else {
      // å•é€‰æ‹–æ‹½ï¼šä½¿ç”¨å½“å‰å•å…ƒæ ¼æ•°æ®
      // è·å–å½“å‰è¡Œçš„ç­‰çº§åç§°ï¼ˆç¬¬ä¸€åˆ—çš„å€¼ï¼‰
      const levelName = this.tableRows[rowIndex]?.[0] || ''
      
      const dragData: DragData = {
        rowIndex,
        colIndex,
        value: cellValue,
        sourceTable: this.tableName,
        levelName: levelName // æ·»åŠ ç­‰çº§åç§°å­—æ®µï¼Œç”¨äºç­‰çº§ç»Ÿè®¡è¡¨è”åŠ¨
      }

      const dragDataStr = JSON.stringify(dragData)
      console.log('ğŸš€ GridTable - å¼€å§‹å•é€‰æ‹–æ‹½:', dragDataStr)

      return {
        pixelMap: undefined,
        builder: undefined,
        extraInfo: dragDataStr
      }
    }
  }

  /**
   * å¤„ç†æ•´è¡Œæ‹–æ‹½å¼€å§‹
   */
  private handleRowDragStart(rowIndex: number, row: TableRow): DragItemInfo {
    if (!this.enableDrag) {
      return { pixelMap: undefined, builder: undefined, extraInfo: '' }
    }

    // å¯¹äºæ•´è¡Œæ‹–æ‹½ï¼Œæˆ‘ä»¬ä¼ é€’ç¬¬ä¸€åˆ—çš„å€¼ä½œä¸ºä¸»è¦æ ‡è¯†
    const primaryValue = row[0] || ''
    
    // æ’é™¤ç¬¬ä¸€åˆ—ï¼ˆç­‰çº§åç§°ï¼‰ï¼Œåªä¼ é€’åé¢çš„æ•°æ®å†…å®¹
    const dataWithoutFirstColumn = row.slice(1)
    
    const dragData: DragData = {
      rowIndex,
      colIndex: -1, // -1è¡¨ç¤ºæ•´è¡Œæ‹–æ‹½
      value: primaryValue,
      sourceTable: this.tableName,
      fullRowData: JSON.stringify(dataWithoutFirstColumn), // æ’é™¤ç¬¬ä¸€åˆ—çš„æ•°æ®
      levelName: primaryValue // æ·»åŠ ç­‰çº§åç§°å­—æ®µï¼Œç”¨äºç­‰çº§ç»Ÿè®¡è¡¨è”åŠ¨
    }

    const dragDataStr = JSON.stringify(dragData)
    console.log('ğŸš€ GridTable - å¼€å§‹æ•´è¡Œæ‹–æ‹½:', dragDataStr)

    return {
      pixelMap: undefined,
      builder: undefined,
      extraInfo: dragDataStr
    }
  }

  /**
   * å¤„ç†æ‹–æ‹½æ”¾ç½®äº‹ä»¶
   * å®ç°å•å…ƒæ ¼å†…å®¹äº¤æ¢
   */
  private handleDrop(fromData: DragData, toRowIndex: number, toColIndex: number): void {
    if (!this.enableDrag) return

    const fromRowIndex = fromData.rowIndex
    const fromColIndex = fromData.colIndex

    // å¦‚æœæ˜¯åŒä¸€ä¸ªå•å…ƒæ ¼ï¼Œä¸å¤„ç†
    if (fromRowIndex === toRowIndex && fromColIndex === toColIndex) {
      return
    }

    console.log('ğŸ¯ GridTable - æ‹–æ‹½äº¤æ¢:', fromData, 'åˆ°', toRowIndex, toColIndex)

    // äº¤æ¢å•å…ƒæ ¼å†…å®¹
    const fromValue = this.tableRows[fromRowIndex][fromColIndex]
    const toValue = this.tableRows[toRowIndex][toColIndex]

    // åˆ›å»ºæ–°çš„æ•°æ®æ•°ç»„ï¼ˆä¿æŒå“åº”å¼ï¼‰
    const newTableRows = this.tableRows.map((row, rowIdx) => {
      if (rowIdx === fromRowIndex) {
        return row.map((cell, colIdx) => {
          if (colIdx === fromColIndex) {
            return toValue
          }
          return cell
        })
      } else if (rowIdx === toRowIndex) {
        return row.map((cell, colIdx) => {
          if (colIdx === toColIndex) {
            return fromValue
          }
          return cell
        })
      }
      return row
    })

    // æ›´æ–°æ•°æ®
    this.tableRows = newTableRows
  }

  /**
   * å¤„ç†æ•´è¡Œæ‹–æ‹½æ”¾ç½®äº‹ä»¶
   * å®ç°æ•´è¡Œäº¤æ¢
   */
  private handleRowDrop(fromData: DragData, toRowIndex: number): void {
    if (!this.enableDrag) return

    const fromRowIndex = fromData.rowIndex

    // å¦‚æœæ˜¯åŒä¸€è¡Œï¼Œä¸å¤„ç†
    if (fromRowIndex === toRowIndex) {
      return
    }

    console.log('ğŸ¯ GridTable - æ•´è¡Œæ‹–æ‹½äº¤æ¢:', fromRowIndex, 'åˆ°', toRowIndex)

    // äº¤æ¢æ•´è¡Œæ•°æ®
    const fromRow = this.tableRows[fromRowIndex]
    const toRow = this.tableRows[toRowIndex]

    // åˆ›å»ºæ–°çš„æ•°æ®æ•°ç»„ï¼ˆä¿æŒå“åº”å¼ï¼‰
    const newTableRows = this.tableRows.map((row, rowIdx) => {
      if (rowIdx === fromRowIndex) {
        return toRow
      } else if (rowIdx === toRowIndex) {
        return fromRow
      }
      return row
    })

    // æ›´æ–°æ•°æ®
    this.tableRows = newTableRows
  }

  /**
   * å¤„ç†æ•´åˆ—æ‹–æ‹½å¼€å§‹
   */
  private handleColumnDragStart(colIndex: number): DragItemInfo {
    if (!this.enableDrag) {
      return { pixelMap: undefined, builder: undefined, extraInfo: '' }
    }

    // è·å–æ•´åˆ—æ•°æ®
    const columnData = this.tableRows.map(row => row[colIndex])
    // è·å–å¯¹åº”çš„ç­‰çº§åç§°ï¼ˆæ¯è¡Œçš„ç¬¬ä¸€åˆ—ï¼‰
    const levelNames = this.tableRows.map(row => row[0] || '')
    
    const dragData: DragData = {
      rowIndex: -1, // -1è¡¨ç¤ºæ•´åˆ—æ‹–æ‹½
      colIndex,
      value: this.headerTitles[colIndex] || '',
      sourceTable: this.tableName,
      fullColumnData: JSON.stringify(columnData),
      levelNames: levelNames // æ·»åŠ ç­‰çº§åç§°æ•°ç»„ï¼Œç”¨äºç­‰çº§ç»Ÿè®¡è¡¨è”åŠ¨
    }

    const dragDataStr = JSON.stringify(dragData)
    console.log('ğŸš€ GridTable - å¼€å§‹æ•´åˆ—æ‹–æ‹½:', dragDataStr)

    return {
      pixelMap: undefined,
      builder: undefined,
      extraInfo: dragDataStr
    }
  }

  /**
   * å¤„ç†æ•´åˆ—æ‹–æ‹½æ”¾ç½®äº‹ä»¶
   * å®ç°æ•´åˆ—äº¤æ¢
   */
  private handleColumnDrop(fromData: DragData, toColIndex: number): void {
    if (!this.enableDrag) return

    const fromColIndex = fromData.colIndex

    // å¦‚æœæ˜¯åŒä¸€åˆ—ï¼Œä¸å¤„ç†
    if (fromColIndex === toColIndex) {
      return
    }

    console.log('ğŸ¯ GridTable - æ•´åˆ—æ‹–æ‹½äº¤æ¢:', fromColIndex, 'åˆ°', toColIndex)

    // äº¤æ¢æ•´åˆ—æ•°æ®
    const newTableRows = this.tableRows.map(row => {
      const newRow = [...row]
      const temp = newRow[fromColIndex]
      newRow[fromColIndex] = newRow[toColIndex]
      newRow[toColIndex] = temp
      return newRow
    })

    // äº¤æ¢è¡¨å¤´
    const newHeaderTitles = [...this.headerTitles]
    const temp = newHeaderTitles[fromColIndex]
    newHeaderTitles[fromColIndex] = newHeaderTitles[toColIndex]
    newHeaderTitles[toColIndex] = temp

    // æ›´æ–°æ•°æ®
    this.tableRows = newTableRows
    this.headerTitles = newHeaderTitles
  }

  /**
   * æ„å»ºæ‹–æ‹½é¢„è§ˆ
   */
  @Builder
  private buildDragPreview(cellValue: string) {
    Text(cellValue)
      .fontSize(24)
      .fontColor(Color.White)
      .backgroundColor('#007DFF')
      .padding(8)
      .borderRadius(6)
      .shadow({ radius: 8, color: 'rgba(0,0,0,0.3)', offsetY: 2 })
  }

  /**
   * æ„å»ºè¡¨æ ¼å•å…ƒæ ¼
   */
  @Builder
  private buildTableCell(cellValue: string, rowIndex: number, colIndex: number) {
    Text(cellValue)
      .fontSize(16)
      .fontColor(this.getCurrentTheme().textColor)
      .textAlign(TextAlign.Center)
      .layoutWeight(1)
      .height('100%')
      .backgroundColor(this.isCellSelected(rowIndex, colIndex) ? '#E3F2FD' : (this.getCurrentTheme().controlBg ?? this.getCurrentTheme().surfaceColor)) // é€‰ä¸­æ—¶é«˜äº®èƒŒæ™¯
      .border({
        width: { right: 1, bottom: 1 },
        color: this.isCellSelected(rowIndex, colIndex) ? '#2196F3' : this.getCurrentTheme().borderColor // é€‰ä¸­æ—¶è“è‰²è¾¹æ¡†
      })
      .padding(2)
      .draggable(this.enableDrag)
      .onClick(() => {
        // ç‚¹å‡»åˆ‡æ¢é€‰ä¸­çŠ¶æ€
        this.toggleCellSelection(rowIndex, colIndex, cellValue)
      })
      .onDragStart((event: DragEvent, extraParams: string): DragItemInfo => {
        return this.handleDragStart(rowIndex, colIndex, cellValue)
      })
      .onDrop((event: DragEvent, extraParams: string) => {
        try {
          const dragData: DragData = JSON.parse(extraParams)
          this.handleDrop(dragData, rowIndex, colIndex)
        } catch (error) {
          console.error('æ‹–æ‹½æ•°æ®è§£æå¤±è´¥:', error)
        }
      })
  }

  /**
   * æ„å»ºè¡¨å¤´å•å…ƒæ ¼
   */
  @Builder
  private buildHeaderCell(title: string, colIndex: number) {
    Text(title)
      .fontSize(18)
      .fontWeight(FontWeight.Bold)
      .fontColor(this.getCurrentTheme().tableHeaderTextColor ?? this.getCurrentTheme().textColor)
      .textAlign(TextAlign.Center)
      .width('100%')
      .height('100%')
      .backgroundColor(this.getCurrentTheme().tableHeaderBg ?? this.getCurrentTheme().controlBg ?? this.getCurrentTheme().surfaceColor)
      .border({
        width: { right: 1, bottom: 1 },
        color: this.getCurrentTheme().borderColor
      })
      .padding(2)
  }

  /**
   * æ„å»ºè¡¨å¤´å·¦ä¸Šè§’ç©ºç™½åŒºåŸŸ
   */
  @Builder
  private buildHeaderCorner() {
    Text('')
      .width(40)
      .height('100%')
      .backgroundColor(this.getCurrentTheme().controlBg ?? this.getCurrentTheme().surfaceColor)
      .border({
        width: { right: 1, bottom: 1 },
        color: this.getCurrentTheme().borderColor
      })
  }

  /**
   * æ„å»ºåˆ—å¤´ - æ”¯æŒæ•´åˆ—æ‹–æ‹½
   */
  @Builder
  private buildColumnHeader(title: string, colIndex: number) {
    Text(title)
      .fontSize(20)
      .fontWeight(FontWeight.Bold)
      .fontColor(this.getCurrentTheme().tableHeaderTextColor ?? this.getCurrentTheme().textColor)
      .textAlign(TextAlign.Center)
      .layoutWeight(1)
      .height('100%')
      .backgroundColor(this.getCurrentTheme().tableHeaderBg ?? this.getCurrentTheme().controlBg ?? this.getCurrentTheme().surfaceColor)
      .border({
        width: { right: 1, bottom: 1 },
        color: this.getCurrentTheme().borderColor
      })
      .padding(6)
      .draggable(this.enableDrag)
      .onDragStart((event: DragEvent, extraParams: string): DragItemInfo => {
        return this.handleColumnDragStart(colIndex)
      })
      .onDrop((event: DragEvent, extraParams: string) => {
        try {
          const dragData: DragData = JSON.parse(extraParams)
          this.handleColumnDrop(dragData, colIndex)
        } catch (error) {
          console.error('æ‹–æ‹½æ•°æ®è§£æå¤±è´¥:', error)
        }
      })
  }

  /**
   * æ„å»ºç¬¬ä¸€åˆ—å•å…ƒæ ¼ - æ”¯æŒæ•´è¡Œæ‹–æ‹½
   */
  @Builder
  private buildRowDragCell(cellValue: string, rowIndex: number, colIndex: number) {
    Text(cellValue)
      .fontSize(16)
      .fontColor(this.getCurrentTheme().textColor)
      .textAlign(TextAlign.Center)
      .layoutWeight(1)
      .height('100%')
      .backgroundColor(this.isCellSelected(rowIndex, colIndex) ? '#E3F2FD' : (this.getCurrentTheme().controlBg ?? this.getCurrentTheme().surfaceColor)) // é€‰ä¸­æ—¶é«˜äº®èƒŒæ™¯
      .border({
        width: { right: 1, bottom: 1 },
        color: this.isCellSelected(rowIndex, colIndex) ? '#2196F3' : this.getCurrentTheme().borderColor // é€‰ä¸­æ—¶è“è‰²è¾¹æ¡†
      })
      .padding(2)
      .draggable(this.enableDrag)
      .onClick(() => {
        // ç‚¹å‡»åˆ‡æ¢é€‰ä¸­çŠ¶æ€
        this.toggleCellSelection(rowIndex, colIndex, cellValue)
      })
      .onDragStart((event: DragEvent, extraParams: string): DragItemInfo => {
        return this.handleRowDragStart(rowIndex, this.tableRows[rowIndex])
      })
      .onDrop((event: DragEvent, extraParams: string) => {
        try {
          const dragData: DragData = JSON.parse(extraParams)
          this.handleRowDrop(dragData, rowIndex)
        } catch (error) {
          console.error('æ‹–æ‹½æ•°æ®è§£æå¤±è´¥:', error)
        }
      })
  }

  build() {
    Column() {
      // è¡¨æ ¼æ ‡é¢˜
      Text(this.tableTitle)
        .fontSize(16)
        .fontWeight(FontWeight.Medium)
        .fontColor(this.getCurrentTheme().textColor)
        .alignSelf(ItemAlign.Start)
        .margin({ bottom: 4 })

      // è¡¨æ ¼å®¹å™¨
      Column() {
        // å›ºå®šè¡¨å¤´
        Row() {
          // åˆ—å¤´ - æ•´åˆ—æ‹–æ‹½
          ForEach(this.headerTitles, (title: string, colIndex: number) => {
            this.buildColumnHeader(title, colIndex)
          })
        }
        .width('100%')
        .height(50)

        // å¯æ»šåŠ¨æ•°æ®åŒºåŸŸ
        Scroll() {
          Column() {
            ForEach(this.tableRows, (row: TableRow, rowIndex: number) => {
              Row() {
                // æ•°æ®å•å…ƒæ ¼ - ç¬¬ä¸€åˆ—æ”¯æŒæ•´è¡Œæ‹–æ‹½ï¼Œå…¶ä»–åˆ—æ”¯æŒå•æ ¼æ‹–æ‹½
                ForEach(row, (cellValue: string, colIndex: number) => {
                  if (colIndex === 0) {
                    // ç¬¬ä¸€åˆ—ï¼ˆå¦‚"Açº§"ã€"Bçº§"ï¼‰æ”¯æŒæ•´è¡Œæ‹–æ‹½
                    this.buildRowDragCell(cellValue, rowIndex, colIndex)
                  } else {
                    // å…¶ä»–åˆ—æ”¯æŒå•æ ¼æ‹–æ‹½
                    this.buildTableCell(cellValue, rowIndex, colIndex)
                  }
                })
              }
              .width('100%')
              .height(65)
            })
          }
          .width('100%')
        }
        .width('100%')
        .height(this.maxHeight)
        .scrollable(ScrollDirection.Vertical)
        .scrollBar(BarState.Auto)
        .scrollBarColor(this.getCurrentTheme().borderColor)
        .scrollBarWidth(6)
        .friction(0.6)
      }
      .width('100%')
      .alignItems(HorizontalAlign.Start)
    }
    .width(this.tableWidth)
    .backgroundColor(this.containerBg || (this.getCurrentTheme().controlBg ?? this.getCurrentTheme().surfaceColor))
    .border({ width: 1, color: this.getCurrentTheme().borderColor })
    .borderRadius(6)
    .padding(4)
    .margin({ top: 4, left: 4, right: 4, bottom: 2 })
    .alignItems(HorizontalAlign.Center)
    .justifyContent(FlexAlign.Center)
  }
}
