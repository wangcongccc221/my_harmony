import { McLineChart } from '@mcui/mccharts'
import { Options } from '@mcui/mccharts'
import { BaseComponentHelper } from '../common/BaseComponent'
import { OmniThemeType, ExtendedOmniThemeStyle } from '../../utils/theme/OmniThemeManager'

// æ•°æ®æ¥å£å®šä¹‰
interface ChartDataItem {
  time: string
  value: number
}

/**
 * åŠ å·¥æ›²çº¿å›¾è¡¨ç»„ä»¶
 * æ˜¾ç¤ºåŠ å·¥è¿›åº¦çš„æŠ˜çº¿å›¾
 */
// TODO(æ€§èƒ½ä¼˜åŒ–-è®¡åˆ’):
// 1) é™åˆ¶å›¾è¡¨ç‚¹æ•°: ä¿æŒæœ€å¤§ç‚¹æ•° maxPoints(å¦‚<=200), è¶…å‡ºä¸¢å¼ƒå¤´éƒ¨æ•°æ®
// 2) åˆ·æ–°èŠ‚æµ: å®æ—¶æ•°æ®æ›´æ–°æ—¶åˆå¹¶åˆ° 100~200ms è§¦å‘ä¸€æ¬¡ setState
// 3) åŠ¨ç”»æ§åˆ¶: é«˜é¢‘æ›´æ–°åœºæ™¯å…³é—­ animation, é™ä½é‡ç»˜å¼€é”€
@Component
export struct ProcessingCurveChart {
  @Prop title: string = 'åŠ å·¥æ›²çº¿'
  @Prop chartHeight: number | string = 200
  @Prop chartWidth: string | number = '100%'
  @Prop data: ChartDataItem[] = []

  // åŸºç¡€ç»„ä»¶åŠ©æ‰‹
  private baseComponentHelper = new BaseComponentHelper()
  @Consume providedTheme: ExtendedOmniThemeStyle

  // æ¨¡æ‹Ÿæ•°æ®ä¸å®šæ—¶å™¨
  private timerId?: number
  private maxPoints: number = 1024 // æœ€å¤šä¿ç•™1024ä¸ªç‚¹ï¼Œç”¨äºå†…å­˜æ³„æ¼æµ‹è¯•
  private dataPoints: ChartDataItem[] = []
  private currentProgress: number = 0
  private dataCount: number = 0 // æ•°æ®è®¡æ•°å™¨
  private clearCount: number = 0 // æ¸…ç©ºæ¬¡æ•°è®¡æ•°å™¨
  @State private followLatest: boolean = true // æ˜¯å¦è‡ªåŠ¨è·Ÿéšæœ€æ–°æ•°æ®

  // é»˜è®¤æ•°æ®ï¼ˆåˆå§‹ä¸€ç»„ï¼‰
  private defaultData: ChartDataItem[] = [
    { time: '08:00', value: 0 },
    { time: '08:30', value: 20 },
    { time: '09:00', value: 40 },
    { time: '09:30', value: 60 },
    { time: '10:00', value: 80 },
    { time: '10:30', value: 90 },
    { time: '11:00', value: 100 }
  ]

  // å›¾è¡¨é…ç½®
  @State chartOptions: Options = new Options({
    title: {
      show: true,
      text: this.title,
      left: 'center',
      top: 10,
      textStyle: {
        fontSize: 24,
        fontWeight: 'bold'
      }
    },
    xAxis: {
      data: this.getTimeLabels(),
      axisLabel: {
        fontSize: 20
      }
    },
    yAxis: {
      name: 'åŠ å·¥é‡(%)',
      nameLocation: 'middle',
      nameGap: 30,
      axisLabel: {
        fontSize: 20
      }
    },
    series: [
      {
        name: 'åŠ å·¥è¿›åº¦',
        data: this.getChartData(),
        type: 'line',
        smooth: true,
        symbol: 'circle',
        symbolSize: 6,
        lineStyle: {
          width: 3,
          color: this.getCurrentTheme().chartLineColor ?? this.getCurrentTheme().primary
        },
        itemStyle: {
          color: this.getCurrentTheme().chartLineColor ?? this.getCurrentTheme().primary
        }
      }
    ],
    tooltip: {
      show: true
    }
  })

  getCurrentTheme(): ExtendedOmniThemeStyle {
    return this.baseComponentHelper.getCurrentTheme(this.providedTheme)
  }

  // è·å–æ—¶é—´æ ‡ç­¾
  private getTimeLabels(): string[] {
    const data = this.getActiveData()
    return data.map(item => item.time)
  }

  // è·å–å›¾è¡¨æ•°æ®
  private getChartData(): number[] {
    const data = this.getActiveData()
    return data.map(item => item.value)
  }

  // é€‰æ‹©ä½¿ç”¨å¤–éƒ¨æ•°æ®è¿˜æ˜¯å†…éƒ¨æ¨¡æ‹Ÿæ•°æ®
  private getActiveData(): ChartDataItem[] {
    if (this.data && this.data.length > 0) { return this.data }
    if (this.dataPoints.length > 0) { return this.dataPoints }
    return this.defaultData
  }

  // æ›´æ–°å›¾è¡¨é…ç½®
  private updateChartOptions() {
    this.chartOptions = new Options({
      title: {
        show: true,
        text: this.title,
        left: 'center',
        top: 10,
        textStyle: {
          fontSize: 24,
          fontWeight: 'bold',
          color: this.getCurrentTheme().textColor
        }
      },
      xAxis: {
        data: this.getTimeLabels(),
        axisLabel: {
          fontSize: 20,
          color: this.getCurrentTheme().textColor
        },
        axisLine: {
          lineStyle: {
            color: this.getCurrentTheme().borderColor
          }
        }
      },
      yAxis: {
        name: 'åŠ å·¥é‡(%)',
        nameLocation: 'middle',
        nameGap: 30,
        axisLabel: {
          fontSize: 20,
          color: this.getCurrentTheme().textColor
        },
        axisLine: {
          lineStyle: {
            color: this.getCurrentTheme().borderColor
          }
        }
      },
      series: [
        {
          name: 'åŠ å·¥è¿›åº¦',
          data: this.getChartData(),
          type: 'line',
          smooth: true,
          symbol: 'circle',
          symbolSize: 6,
          lineStyle: {
            width: 3,
            color: this.getCurrentTheme().chartLineColor ?? this.getCurrentTheme().primary
          },
          itemStyle: {
            color: this.getCurrentTheme().chartLineColor ?? this.getCurrentTheme().primary
          }
        }
      ],
      tooltip: {
        show: true,
        backgroundColor: this.getCurrentTheme().chartBg ?? this.getCurrentTheme().surfaceColor,
        borderColor: this.getCurrentTheme().borderColor,
        textStyle: {
          color: this.getCurrentTheme().textColor
        }
      },
      // è‡ªåŠ¨è¿½è¸ªæœ€æ–°æ•°æ®é…ç½®ï¼ˆæš‚æ—¶ç§»é™¤ï¼Œä½¿ç”¨å…¶ä»–æ–¹å¼å®ç°ï¼‰
      // dataZoom: {
      //   type: 'inside',
      //   xAxisIndex: 0,
      //   start: this.followLatest ? 100 : 0,
      //   end: 100
      // }
    })
  }

  // ===== æ¨¡æ‹Ÿï¼šæ¯ç§’è¿½åŠ ä¸€ä¸ªæ—¶é—´ç‚¹ä¸éšæœºè¿›åº¦ =====
  private startMockIfNeeded() {
    // ä»…å½“æœªæä¾›å¤–éƒ¨ data æ—¶æ‰æ¨¡æ‹Ÿ
    if (this.data && this.data.length > 0) { return }
    // åˆå§‹åŒ–å†…éƒ¨æ•°æ®ä¸ºé»˜è®¤æ•°æ®
    if (this.dataPoints.length === 0) {
      this.dataPoints = [...this.defaultData]
      this.currentProgress = this.dataPoints[this.dataPoints.length - 1]?.value ?? 0
      this.dataCount = this.dataPoints.length
    }
    if (this.timerId) { return }
    this.timerId = setInterval(() => {
      const now = new Date()
      const hh = String(now.getHours()).padStart(2, '0')
      const mm = String(now.getMinutes()).padStart(2, '0')
      const ss = String(now.getSeconds()).padStart(2, '0')
      // éšæœºæ¸¸èµ°å¹¶é™åˆ¶åœ¨ 0~100
      const step = (Math.random() * 10) - 5 // -5 ~ +5
      this.currentProgress = Math.max(0, Math.min(100, Math.round(this.currentProgress + step)))
      this.dataPoints.push({ time: `${hh}:${mm}:${ss}`, value: this.currentProgress })
      this.dataCount++
      
      // æ§åˆ¶å°è¾“å‡ºå½“å‰æ•°æ®æ¡æ•°
      console.log(`ğŸ“Š ç¬¬${this.dataCount}æ¡æ•°æ® - æ—¶é—´: ${hh}:${mm}:${ss} - è¿›åº¦: ${this.currentProgress}%`)
      
      // å½“æ•°æ®è¾¾åˆ°1024ä¸ªæ—¶ï¼Œæ¸…ç©ºæ‰€æœ‰æ•°æ®é‡æ–°å¼€å§‹
      if (this.dataCount >= this.maxPoints) {
        console.log(`ğŸ”„ æ•°æ®è¾¾åˆ°${this.maxPoints}ä¸ªï¼Œå¼€å§‹æ¸…ç©ºæ•°æ®... (ç¬¬${this.clearCount + 1}æ¬¡æ¸…ç©º)`)
        this.dataPoints = []
        this.dataCount = 0
        this.clearCount++
        this.currentProgress = 0
        
        // é‡æ–°åˆå§‹åŒ–æ•°æ®
        this.dataPoints = [...this.defaultData]
        this.dataCount = this.dataPoints.length
        this.currentProgress = this.dataPoints[this.dataPoints.length - 1]?.value ?? 0
        
        console.log(`âœ… æ•°æ®å·²æ¸…ç©ºï¼Œé‡æ–°å¼€å§‹è¿½è¸ª (æ¸…ç©ºæ¬¡æ•°: ${this.clearCount})`)
      }
      
      // ä½¿ç”¨ Options.setVal å¢é‡æ›´æ–°ï¼ˆå®˜æ–¹æ¨èï¼‰
      this.chartOptions.setVal({
        xAxis: { data: this.getTimeLabels() },
        series: [ { name: 'åŠ å·¥è¿›åº¦', data: this.getChartData() } ]
        // è‡ªåŠ¨è¿½è¸ªæœ€æ–°æ•°æ®ï¼ˆæš‚æ—¶ç§»é™¤dataZoomé…ç½®ï¼‰
        // dataZoom: {
        //   type: 'inside',
        //   xAxisIndex: 0,
        //   start: this.followLatest ? 100 : 0,
        //   end: 100
        // }
      })
    }, 1000) as number
  }

  private stopMock() {
    if (this.timerId) {
      clearInterval(this.timerId)
      this.timerId = undefined
    }
  }

  aboutToAppear() {
    // åˆå§‹åŒ–é…ç½®å¹¶å°è¯•å¯åŠ¨æ¨¡æ‹Ÿ
    this.dataPoints = (this.data && this.data.length > 0) ? [] : [...this.defaultData]
    this.updateChartOptions()
    this.startMockIfNeeded()
  }

  aboutToUpdate() {
    this.updateChartOptions()
  }

  aboutToDisappear() {
    this.stopMock()
  }

  build() {
    Column() {
      // æ•°æ®ç»Ÿè®¡ä¿¡æ¯æ˜¾ç¤º
      Row() {
        Text(`æ•°æ®ç‚¹: ${this.dataCount}/${this.maxPoints}`)
          .fontSize(14)
          .fontColor(this.getCurrentTheme().textColor)
          .margin({ right: 16 })
        
        Text(`æ¸…ç©ºæ¬¡æ•°: ${this.clearCount}`)
          .fontSize(14)
          .fontColor(this.getCurrentTheme().primary)
          .margin({ right: 16 })
        
        Text(`å½“å‰è¿›åº¦: ${this.currentProgress}%`)
          .fontSize(14)
          .fontColor(this.getCurrentTheme().chartLineColor ?? this.getCurrentTheme().primary)
          .margin({ right: 16 })
        
        // è‡ªåŠ¨è¿½è¸ªå¼€å…³ï¼ˆæš‚æ—¶æ³¨é‡Šæ‰ï¼Œé»˜è®¤å¼€å¯ï¼‰
        // Text(`è‡ªåŠ¨è¿½è¸ª: ${this.followLatest ? 'å¼€å¯' : 'å…³é—­'}`)
        //   .fontSize(14)
        //   .fontColor(this.followLatest ? this.getCurrentTheme().primary : this.getCurrentTheme().subTextColor)
        //   .onClick(() => {
        //     this.followLatest = !this.followLatest
        //   })
      }
      .width('100%')
      .justifyContent(FlexAlign.Start)
      .padding({ left: 16, right: 16, top: 8, bottom: 8 })
      .backgroundColor(this.getCurrentTheme().controlBg ?? this.getCurrentTheme().surfaceColor)
      .borderRadius(4)
      .margin({ bottom: 8 })

      McLineChart({
        options: this.chartOptions
      })
      .width(this.chartWidth)
      .height(this.chartHeight)
    }
    .width('100%')
    .height('100%')
    .backgroundColor(this.getCurrentTheme().chartBg ?? this.getCurrentTheme().surfaceColor)
  }
}
