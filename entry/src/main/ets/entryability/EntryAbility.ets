import { AbilityConstant, ConfigurationConstant, UIAbility, Want } from '@kit.AbilityKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { window } from '@kit.ArkUI';
import { taskpool, util } from '@kit.ArkTS';
import { copyRawDirectoryAuto } from '../utils/FileUtils';
import { AppCleanup } from '../utils/lifecycle/AppCleanup';
import { ProcessingCurveFeed } from '../utils/data/ProcessingCurveFeed';
import { ProcessingBarFeed } from '../utils/data/ProcessingBarFeed';
import { MultiSeriesBarFeed } from '../utils/data/MultiSeriesBarFeed';
import { WavePhaseManager } from '../utils/ui/WavePhaseManager';

import { DbManager } from '../db/DbManager';
import { I18nManager } from '../utils/i18n/I18nManager';
import { OutletCountStorage } from '../utils/storage/OutletCountStorage';
import { NativeModule, CommandHead } from '../utils/native/NativeModule';
import { getUIDataSync } from '../protocol/UIDataSync';
import { getStatisticsHandler } from '../protocol/StatisticsHandler';
import { getDatabaseSync } from '../protocol/DatabaseSync'
import { OrmDatabaseSaver } from '../protocol/OrmDatabaseSaver'
import { getGlobalDataInterface } from '../protocol/GlobalDataInterface'
import { ConstPreDefine } from '../protocol/ConstPreDefine';
import { getConfigSender, ITcpSender } from '../protocol/ConfigSender';
import { tcpSendOnce } from '../protocol/ArkTcpClient'
import { FSM_HC_COMMAND_TYPE, IPM_HC_COMMAND_TYPE, WAM_HC_COMMAND_TYPE } from '../protocol/CommandTypes'

const DOMAIN = 0x0000;
const HTTP_SERVER_PORT: number = 8080;

class TcpSenderImpl implements ITcpSender {
  async sendToDevice(deviceId: number, data: ArrayBuffer): Promise<boolean> {
    const overrideIp = AppStorage.get('MOCK_DEVICE_IP') as string | undefined
    const ip = overrideIp ?? ConstPreDefine.getIpFromId(deviceId)
    const ipmIdx = (deviceId >> 4) & 0x0F
    const overridePort = AppStorage.get('MOCK_DEVICE_PORT') as number | undefined
    const port = (overridePort !== undefined && overridePort > 0) ? overridePort : (ipmIdx > 0 ? ConstPreDefine.IPM_PORT_NUM : ConstPreDefine.FSM_PORT_NUM)
    return tcpSendOnce(ip, port, data)
  }
  async sendToAllDevices(data: ArrayBuffer): Promise<void> {
    return
  }
  isDeviceConnected(deviceId: number): boolean {
    return true
  }
}

export default class EntryAbility extends UIAbility {
  private httpServerInitialized: boolean = false; 
  private dbInitPromise: Promise<void> | null = null

  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    this.context.getApplicationContext().setColorMode(ConfigurationConstant.ColorMode.COLOR_MODE_NOT_SET);
    hilog.info(DOMAIN, 'testTag', '%{public}s', 'Ability onCreate');

    // åˆå§‹åŒ– Native æœåŠ¡
    this.initNativeServers();

    // åˆå§‹åŒ–æ•°æ®åº“é…ç½®
    this.dbInitPromise = DbManager.getInstance().init(this.context);

    // å¯åŠ¨ UI æ•°æ®åŒæ­¥æœåŠ¡ (è¿æ¥åè®®å±‚ä¸UIå±‚)
    this.startUIDataSync();

    // [DEBUG] æ³¨å…¥æ¨¡æ‹Ÿçš„å‡ºå£é…ç½®æ•°æ® (ç”¨äºå±•ç¤ºè‡ªå®šä¹‰åç§°å’Œåˆ—è¡¨)
    this.injectMockExitConfig();

    this.copyResourceFiles();
    // this.initNetworkOptimizer();
    // this.initHttpServer();
    // åˆå§‹åŒ–è‡ªå®šä¹‰ç¿»è¯‘ï¼ˆJSON æ¨¡å¼ï¼‰
    I18nManager.getInstance().init(this.context).catch((e: Error | object | string) => {
      const reason = typeof e === 'string'
        ? e
        : (e instanceof Error ? e.message : JSON.stringify(e));
      hilog.warn(DOMAIN, 'EntryAbility', `I18n åˆå§‹åŒ–å¤±è´¥: ${reason}`);
    });
  }
  
  /**
   * åˆå§‹åŒ– Native æœåŠ¡
   * å¯åŠ¨ SocketServer (PLC) å’Œ TcpServer (ä¸šåŠ¡)
   */
  private initNativeServers(): void {
    try {
      console.info('========== å¼€å§‹åˆå§‹åŒ– Native æœåŠ¡ ==========');

      // 1. å¯åŠ¨ SocketServer (PLCæ§åˆ¶) - ç«¯å£ 8080
      console.info('ğŸš€ [SocketServer] å°è¯•å¯åŠ¨ (PLC)...');
      const socketSuccess = NativeModule.socketServerStart("", 8080, (clientIP, data) => {
        const dataLen = data.length;
        console.info(`ğŸ“¡ [SocketServer] æ”¶åˆ°æ•°æ® | æ¥è‡ª: ${clientIP} | é•¿åº¦: ${dataLen}`);
        try {
          const bytes = data instanceof Uint8Array ? data : new Uint8Array(data)
          const decoder = new util.TextDecoder()
          const cmd = decoder.decodeWithStream(bytes).trim()
          if (cmd === 'END_CLEAR' || cmd === 'END_SAVE') {
            Promise.resolve().then(async () => {
              const dbSync = getDatabaseSync()
              const gdi = getGlobalDataInterface()
              await dbSync.saveNow()
              const ok = await dbSync.endCurrentBatch()
              if (ok) {
                gdi.stopProcessing()
                gdi.clearData()
              }
            })
          }
        } catch (_) {}
      });
      
      if (socketSuccess) {
        console.info('âœ… [SocketServer] å¯åŠ¨æˆåŠŸ (Port: 8080)');
      } else {
        console.error('âŒ [SocketServer] å¯åŠ¨å¤±è´¥');
      }


      console.info('ğŸš€ [TcpServer] å°è¯•å¯åŠ¨ (ä¸šåŠ¡)...');

      const tcpSuccess = NativeModule.tcpServerStart("", ConstPreDefine.HC_PORT2_NUM, ConstPreDefine.HC_ID, (head: CommandHead) => {
        if (!head || !head.data) {
          return
        }
        // ç»Ÿè®¡æœåŠ¡ï¼šåªå¤„ç† FSM/WAM ç»Ÿè®¡ç›¸å…³å‘½ä»¤
        const isFsmCmd = head.cmdId >= FSM_HC_COMMAND_TYPE.FSM_CMD_CONFIG &&
          head.cmdId <= FSM_HC_COMMAND_TYPE.FSM_CMD_BOOT_FLASH_PROGRESS
        const isWamCmd = head.cmdId >= WAM_HC_COMMAND_TYPE.WAM__CMD_WEIGHT_INFO &&
          head.cmdId <= WAM_HC_COMMAND_TYPE.WAM_CMD_REP_WAM_INFO
        if (isFsmCmd || isWamCmd) {
          getStatisticsHandler().handleSplitMessage(head.cmdId, head.srcId, head.data);
        } else {
          console.warn(`[TcpServer-Stat] å¿½ç•¥éç»Ÿè®¡å‘½ä»¤ cmd=0x${head.cmdId.toString(16)} src=0x${head.srcId.toString(16)}`)
        }
      });

      if (tcpSuccess) {
        console.info(`âœ… [TcpServer] å¯åŠ¨æˆåŠŸ (Port: ${ConstPreDefine.HC_PORT2_NUM})`);
      } else {
        console.error('âŒ [TcpServer] å¯åŠ¨å¤±è´¥');
      }

      console.info('ğŸš€ [TcpServer-Image] å°è¯•å¯åŠ¨ (å›¾åƒ)...');
      const tcpImageSuccess = NativeModule.tcpServerStart("", ConstPreDefine.HC_PORT1_NUM, ConstPreDefine.HC_ID, (head: CommandHead) => {
        if (!head || !head.data) {
          return
        }
        const isIpmImageCmd = head.cmdId >= IPM_HC_COMMAND_TYPE.IPM_CMD_IMAGE &&
          head.cmdId <= IPM_HC_COMMAND_TYPE.IPM_CMD_SHUTTER_ADJUST
        if (isIpmImageCmd) {
          console.info(`[TcpServer-Image] æ”¶åˆ°å›¾åƒé“¾è·¯å‘½ä»¤ cmd=0x${head.cmdId.toString(16)} src=0x${head.srcId.toString(16)} len=${head.length}`)
          // é¢„ç•™ï¼šåç»­åœ¨è¿™é‡Œæ¥å…¥å›¾åƒè§£æ/æ˜¾ç¤ºæµç¨‹
        } else {
          console.warn(`[TcpServer-Image] å¿½ç•¥éå›¾åƒå‘½ä»¤ cmd=0x${head.cmdId.toString(16)} src=0x${head.srcId.toString(16)}`)
        }
      });
      if (tcpImageSuccess) {
        console.info(`âœ… [TcpServer-Image] å¯åŠ¨æˆåŠŸ (Port: ${ConstPreDefine.HC_PORT1_NUM})`);
      } else {
        console.error('âŒ [TcpServer-Image] å¯åŠ¨å¤±è´¥');
      }

      const tcpSender = new TcpSenderImpl()
      getConfigSender().setTcpSender(tcpSender)
      
      // 3. (å¯é€‰) TcpClient è¿æ¥ç¤ºä¾‹
      // å¦‚æœéœ€è¦åœ¨å¯åŠ¨æ—¶è¿æ¥æŸä¸ªæœåŠ¡å™¨ï¼Œå¯ä»¥åœ¨è¿™é‡Œè°ƒç”¨
      /*
      NativeModule.tcpClientConnect("192.168.1.100", 8888, (data) => {
        console.info(`[TcpClient] æ”¶åˆ°æ•°æ®: ${data.length}`);
      });
      */

      console.info('========== Native æœåŠ¡åˆå§‹åŒ–å®Œæˆ ==========');
    } catch (error) {
      console.error('âŒ Native æœåŠ¡åˆå§‹åŒ–å¤±è´¥:', error);
    }
  }
  
  /**
   * [DEBUG] æ³¨å…¥æ¨¡æ‹Ÿçš„å‡ºå£é…ç½®æ•°æ®
   */
  private injectMockExitConfig(): void {
    try {
      console.info('========== [DEBUG] æ³¨å…¥æ¨¡æ‹Ÿå‡ºå£é…ç½® ==========');
      
      const mockNames = ['ç‰¹çº§æœ', 'ä¸€çº§æœ', 'äºŒçº§æœ', 'ä¸‰çº§æœ', 'ç­‰å¤–æœ'];
      const mockCriteria = [
        ['é‡é‡>250g', 'ç³–åº¦>15', 'æ— ç‘•ç–µ'],
        ['é‡é‡>200g', 'ç³–åº¦>13', 'å¾®ç‘•ç–µ'],
        ['é‡é‡>150g', 'ç³–åº¦>11'],
        ['é‡é‡>100g'],
        ['é‡é‡<100g', 'ä¸¥é‡ç‘•ç–µ']
      ];

      for (let i = 0; i < 20; i++) {
        // 1. è®¾ç½®è‡ªå®šä¹‰åç§°
        const nameIndex = i % mockNames.length;
        const customName = `${mockNames[nameIndex]} (${i + 1}å·)`;
        AppStorage.setOrCreate(`EXIT_NAME_${i + 1}`, customName);

        // 2. è®¾ç½®åˆ—è¡¨å†…å®¹
        const criteria = mockCriteria[nameIndex];
        AppStorage.setOrCreate(`EXIT_ITEMS_${i + 1}`, criteria);
        
      }
      
      console.info('âœ… æ¨¡æ‹Ÿå‡ºå£é…ç½®æ³¨å…¥å®Œæˆ');
    } catch (e) {
      console.error('âŒ æ¨¡æ‹Ÿé…ç½®æ³¨å…¥å¤±è´¥:', e);
    }
  }

  private async initOutletCountStorage(): Promise<void> {
    try {
      const storage = OutletCountStorage.getInstance();
      await storage.init(this.context);
      
      // åŠ è½½ä¿å­˜çš„å‡ºå£æ•°é‡å¹¶è®¾ç½®åˆ° AppStorage
      const counts = await storage.loadAllOutletCounts();
      AppStorage.setOrCreate('OutletCount_FSM1', counts.fsm1);
      AppStorage.setOrCreate('OutletCount_FSM2', counts.fsm2);
      
      hilog.info(DOMAIN, 'EntryAbility', `å‡ºå£æ•°é‡å·²åŠ è½½: FSM1=${counts.fsm1}, FSM2=${counts.fsm2}`);
    } catch (e) {
      hilog.error(DOMAIN, 'EntryAbility', `å‡ºå£æ•°é‡å­˜å‚¨åˆå§‹åŒ–å¤±è´¥: ${JSON.stringify(e)}`);
      // ä½¿ç”¨é»˜è®¤å€¼
      AppStorage.setOrCreate('OutletCount_FSM1', 20);
      AppStorage.setOrCreate('OutletCount_FSM2', 20);
    }
  }

  onDestroy(): void {
    hilog.info(DOMAIN, 'testTag', '%{public}s', 'Ability onDestroy');

    // this.networkOptimizer.stop();
    
    /*
    if (isHttpServerRunning()) {
      stopHttpServer();
      this.httpServerInitialized = false; 
      hilog.info(DOMAIN, 'EntryAbility', 'HTTPæœåŠ¡å™¨å·²åœæ­¢');
    }
    */

    AppCleanup.shutdownAll();
  }
  
  /**
   * å¯åŠ¨ UI æ•°æ®åŒæ­¥æœåŠ¡
   * å°†åè®®å±‚çš„ä¸‹ä½æœºæ•°æ®åŒæ­¥åˆ° UI ç»„ä»¶
   */
  private startUIDataSync(): void {
    try {
      const uiDataSync = getUIDataSync();
      uiDataSync.start();
      hilog.info(DOMAIN, 'EntryAbility', 'UIæ•°æ®åŒæ­¥æœåŠ¡å·²å¯åŠ¨');
    } catch (e) {
      hilog.error(DOMAIN, 'EntryAbility', `UIæ•°æ®åŒæ­¥æœåŠ¡å¯åŠ¨å¤±è´¥: ${JSON.stringify(e)}`);
    }
  }

  async onWindowStageCreate(windowStage: window.WindowStage): Promise<void> {
    // Main window is created, set main page for this ability
    hilog.info(DOMAIN, 'testTag', '%{public}s', 'Ability onWindowStageCreate');

    try {
      if (this.dbInitPromise) {
        await this.dbInitPromise
      }
      const dbSync = getDatabaseSync()
      dbSync.setDatabaseSaver(new OrmDatabaseSaver())
      dbSync.start()
      dbSync.enableAutoSave(5000)
      /*
      await GlobalStore.init(this.context, {
        name: 'db_fruitsor.db',
        securityLevel: relationalStore.SecurityLevel.S2,
      });
      GetIBestORM().AutoMigrate(ProcessingHistory);
      GetIBestORM().AutoMigrate(FruitInfo);
      GetIBestORM().AutoMigrate(GradeInfo);
      GetIBestORM().AutoMigrate(ExportInfo);
      GetIBestORM().AutoMigrate(FarmerInfo);
      GetIBestORM().AutoMigrate(ProcessingTask);
      GetIBestORM().AutoMigrate(AlarmInfo);
      // åˆ›å»ºç´¢å¼•ä»¥ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½
      ProcessingHistory.createIndexes();
      FruitInfo.createIndexes();
      GradeInfo.createIndexes();
      ExportInfo.createIndexes();
      FarmerInfo.createIndexes();
      ProcessingTask.createIndexes();
      AlarmInfo.createIndexes();
      hilog.info(DOMAIN, 'EntryAbility', 'ORM åˆå§‹åŒ–å®Œæˆå¹¶è¿ç§»æ‰€æœ‰è¡¨');
      */

    } catch (e) {
      hilog.error(DOMAIN, 'EntryAbility', `æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥: ${JSON.stringify(e)}`);
    }

    // ç¡®ä¿å‡ºå£æ•°é‡å­˜å‚¨å·²åˆå§‹åŒ–å¹¶åŠ è½½æ•°æ®
    await this.initOutletCountStorage();

    // å¯åŠ¨ UI æ•°æ®åŒæ­¥æœåŠ¡ - å°†ä¸‹ä½æœºæ•°æ®åŒæ­¥åˆ° UI
    this.startUIDataSync();

    windowStage.loadContent('pages/Home', async (err) => { 
      if (err.code) {
        hilog.error(DOMAIN, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err));
        return;
      }
      hilog.info(DOMAIN, 'testTag', 'Succeeded in loading the content.');
      try {
        const mainWindow: window.Window = await windowStage.getMainWindow();
        await mainWindow.setWindowLayoutFullScreen(true);
        await mainWindow.setFullScreen(true);
      } catch (e) {
        hilog.error(DOMAIN, 'testTag', `set non-fullscreen failed: ${JSON.stringify(e)}`);
      }

      // æ³¨å†Œå…¨å±€é”®ç›˜ç›‘å¬ï¼ˆå·¦ Ctrlï¼‰ï¼Œä¾›å…¨å±€å¤šé€‰ç­‰åŠŸèƒ½ä½¿ç”¨
    });
  }

  onWindowStageDestroy(): void {
    // Main window is destroyed, release UI related resources
    hilog.info(DOMAIN, 'testTag', '%{public}s', 'Ability onWindowStageDestroy');
  }

  onForeground(): void {
    // Ability has brought to foreground
    hilog.info(DOMAIN, 'testTag', '%{public}s', 'Ability onForeground');
    
    Promise.resolve().then(() => {
      try {
        // æ¢å¤æ‰€æœ‰å…¨å±€å®šæ—¶å™¨å’ŒåŠ¨ç”»
        WavePhaseManager.getInstance().resume();
        
        hilog.info(DOMAIN, 'EntryAbility', 'å‰å°æ¢å¤ï¼šå·²æ¢å¤æ‰€æœ‰å…¨å±€å®šæ—¶å™¨å’ŒåŠ¨ç”»');
      } catch (e) {
        hilog.error(DOMAIN, 'EntryAbility', `å‰å°æ¢å¤å¤±è´¥: ${JSON.stringify(e)}`);
      }
    });
  }

  onBackground(): void {
    // Ability has back to background
    hilog.info(DOMAIN, 'testTag', '%{public}s', 'Ability onBackground');
    
    Promise.resolve().then(() => {
      try {
        ProcessingCurveFeed.getInstance().stop();
        ProcessingBarFeed.getInstance().stop();
        MultiSeriesBarFeed.getInstance().stop();
        WavePhaseManager.getInstance().stop();
        
        hilog.info(DOMAIN, 'EntryAbility', 'åå°æ¸…ç†ï¼šå·²åœæ­¢æ‰€æœ‰å…¨å±€å®šæ—¶å™¨');
      } catch (e) {
        hilog.error(DOMAIN, 'EntryAbility', `åå°æ¸…ç†å¤±è´¥: ${JSON.stringify(e)}`);
      }
    });
  }

  onStop(): void {

    hilog.info(DOMAIN, 'EntryAbility', 'onStop: æ‰§è¡Œå…¨å±€æ¸…ç†');
    // AppCleanup.shutdownAll();
  }


  private async initNetworkOptimizer() {
    /*
    try {
      hilog.info(DOMAIN, 'EntryAbility', 'å¼€å§‹åˆå§‹åŒ–ç½‘ç»œä¼˜åŒ–å™¨');

      const success = await this.networkOptimizer.initialize();
      if (success) {
        hilog.info(DOMAIN, 'EntryAbility', 'ç½‘ç»œä¼˜åŒ–å™¨åˆå§‹åŒ–æˆåŠŸ');
      } else {
        hilog.error(DOMAIN, 'EntryAbility', 'ç½‘ç»œä¼˜åŒ–å™¨åˆå§‹åŒ–å¤±è´¥');
      }
    } catch (error) {
      hilog.error(DOMAIN, 'EntryAbility', `ç½‘ç»œä¼˜åŒ–å™¨åˆå§‹åŒ–å¼‚å¸¸: ${error.message}`);
    }
    */
  }

  private async initHttpServer() {
    /*
    if (this.httpServerInitialized) {
      hilog.warn(DOMAIN, 'EntryAbility', 'HTTPæœåŠ¡å™¨å·²ç»åˆå§‹åŒ–è¿‡ï¼Œè·³è¿‡é‡å¤å¯åŠ¨');
      return;
    }
    
    if (isHttpServerRunning()) {
      hilog.warn(DOMAIN, 'EntryAbility', 'HTTPæœåŠ¡å™¨å·²ç»åœ¨è¿è¡Œä¸­ï¼Œè·³è¿‡é‡å¤å¯åŠ¨');
      this.httpServerInitialized = true;
      return;
    }
    
    try {
      hilog.info(DOMAIN, 'EntryAbility', 'å¼€å§‹å¯åŠ¨HTTPæœåŠ¡å™¨');
      HttpServerHandler.setFileBasePath(this.context);
      const task: taskpool.Task = new taskpool.Task(runHttpServerWorker, this.context as common.Context, HTTP_SERVER_PORT);
      taskpool.execute(task);
      this.httpServerInitialized = true;
      hilog.info(DOMAIN, 'EntryAbility', `HTTPæœåŠ¡å™¨å¯åŠ¨æˆåŠŸï¼Œç›‘å¬ç«¯å£: ${HTTP_SERVER_PORT}`);
    } catch (error) {
      hilog.error(DOMAIN, 'EntryAbility', `HTTPæœåŠ¡å™¨å¯åŠ¨å¤±è´¥: ${error.message}`);
      this.httpServerInitialized = false;
    }
    */
  }

  private async copyResourceFiles() {
    try {
      hilog.info(DOMAIN, 'EntryAbility', 'å¼€å§‹è‡ªåŠ¨å¤åˆ¶èµ„æºæ–‡ä»¶...');
      

      const result = await copyRawDirectoryAuto(
        this.context,
        'file',
        undefined,
        'file'
      );
      
      hilog.info(DOMAIN, 'EntryAbility', `èµ„æºæ–‡ä»¶å¤åˆ¶æˆåŠŸ: ${result.fileCount} ä¸ªæ–‡ä»¶å·²å¤åˆ¶åˆ° ${result.targetPath}`);
      hilog.info(DOMAIN, 'EntryAbility', `å¤åˆ¶çš„æ–‡ä»¶åˆ—è¡¨: ${result.fileList.join(', ')}`);
    } catch (error) {
      hilog.error(DOMAIN, 'EntryAbility', `èµ„æºæ–‡ä»¶å¤åˆ¶å¤±è´¥: ${error instanceof Error ? error.message : JSON.stringify(error)}`);
    }
  }
}
