import { hilog } from '@kit.PerformanceAnalysisKit';
import { util } from '@kit.ArkTS';
import { fileIo as fs } from '@kit.CoreFileKit';
import { Context } from '@kit.AbilityKit';
import { HttpRequestHandler } from './HttpServer';
import { listFilesInDirectory, getDefaultStoragePath } from '../FileUtils';
import { ArkDataDemoService, ProcessingRow, ProcessingInsertParams } from '../../db/ArkDataDemo';

const DOMAIN = 0x0000;

/**
 * æ–‡ä»¶é¡¹æ¥å£
 */
interface FileItem {
  name: string;
  isDir: boolean;
  path: string;
}

/**
 * HTTPæœåŠ¡å™¨è¯·æ±‚å¤„ç†å™¨
 * åŠŸèƒ½ï¼šå¤„ç†æ‰€æœ‰HTTPè¯·æ±‚ï¼Œè¿”å›è‡ªå®šä¹‰å“åº”
 * ç”¨é€”ï¼šç»Ÿä¸€ç®¡ç†HTTPæœåŠ¡å™¨çš„å“åº”é€»è¾‘
 */
export class HttpServerHandler {
  private static fileBasePath: string = ''; // å­˜å‚¨æ–‡ä»¶åŸºç¡€è·¯å¾„
  private static textEncoder: util.TextEncoder = new util.TextEncoder();
  private static textDecoder: util.TextDecoder = util.TextDecoder.create('utf-8');
  // åŠ å·¥å†å²ç¼“å­˜
  private static processingCacheLoaded: boolean = false;
  private static processingCache: ProcessingRow[] = [];
  private static getProcessingCacheFile(): string {
    return `${HttpServerHandler.fileBasePath}/processing_cache.json`;
  }
  private static loadProcessingCacheFromDisk(): void {
    try {
      const fp = HttpServerHandler.getProcessingCacheFile();
      if (fs.accessSync(fp)) {
        const f = fs.openSync(fp, fs.OpenMode.READ_ONLY);
        const st = fs.statSync(fp);
        const buf = new ArrayBuffer(st.size);
        fs.readSync(f.fd, buf);
        fs.closeSync(f.fd);
        const arr = new Uint8Array(buf);
        const txt = HttpServerHandler.textDecoder.decode(arr);
        const data = JSON.parse(txt) as ProcessingRow[];
        if (data && data instanceof Array) {
          HttpServerHandler.processingCache = data;
          HttpServerHandler.processingCacheLoaded = true;
        }
      }
    } catch (_) {}
  }
  private static saveProcessingCacheToDisk(): void {
    try {
      const list = HttpServerHandler.processingCache || [];
      const txt = JSON.stringify(list);
      const arr = HttpServerHandler.textEncoder.encodeInto(txt);
      const fp = HttpServerHandler.getProcessingCacheFile();
      const f = fs.openSync(fp, fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);
      fs.writeSync(f.fd, arr);
      fs.closeSync(f.fd);
    } catch (_) {}
  }
  private static toBase64(data: Uint8Array): string {
    let base64 = '';
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    for (let i = 0; i < data.length; i += 3) {
      const b1 = data[i] || 0;
      const b2 = data[i + 1] || 0;
      const b3 = data[i + 2] || 0;
      const bitmap = (b1 << 16) | (b2 << 8) | b3;
      base64 += chars.charAt((bitmap >> 18) & 63);
      base64 += chars.charAt((bitmap >> 12) & 63);
      base64 += (i + 1 < data.length) ? chars.charAt((bitmap >> 6) & 63) : '=';
      base64 += (i + 2 < data.length) ? chars.charAt(bitmap & 63) : '=';
    }
    return base64;
  }

  /**
   * è®¾ç½®æ–‡ä»¶æµè§ˆçš„åŸºç¡€è·¯å¾„
   */
  static setFileBasePath(context: Context): void {
    HttpServerHandler.fileBasePath = getDefaultStoragePath(context);
    hilog.info(DOMAIN, 'HttpServerHandler', `æ–‡ä»¶æµè§ˆåŸºç¡€è·¯å¾„å·²è®¾ç½®: ${HttpServerHandler.fileBasePath}`);
    console.log(`HTTPæœåŠ¡å™¨æ–‡ä»¶æµè§ˆåŸºç¡€è·¯å¾„: ${HttpServerHandler.fileBasePath}`);
    console.log(`HTTPæœåŠ¡å™¨å®é™…æµè§ˆç›®å½•å°†æ˜¯: ${HttpServerHandler.fileBasePath}/file`);
  }

  /**
   * é»˜è®¤HTTPè¯·æ±‚å¤„ç†å™¨
   * å¯ä»¥æ ¹æ®rawRequestè§£æè¯·æ±‚å†…å®¹ï¼Œè¿”å›ç›¸åº”çš„å“åº”
   */
  static createHandler(): HttpRequestHandler {
    return (rawRequest: string): string => {
      hilog.info(DOMAIN, 'HttpServerHandler', `æ”¶åˆ°HTTPè¯·æ±‚: ${rawRequest.substring(0, 200)}...`);
      
      // TODO: åœ¨è¿™é‡Œæ·»åŠ ä½ çš„è¯·æ±‚å¤„ç†é€»è¾‘
      // ä¾‹å¦‚ï¼šè§£æURLã€è¯·æ±‚æ–¹æ³•ã€å‚æ•°ç­‰
      // ä¾‹å¦‚ï¼šæ ¹æ®ä¸åŒè·¯å¾„è¿”å›ä¸åŒå†…å®¹
      // ä¾‹å¦‚ï¼šè°ƒç”¨ä¸šåŠ¡é€»è¾‘å¤„ç†æ•°æ®
      
      // é»˜è®¤å“åº”
      return HttpServerHandler.getDefaultResponse();
    };
  }

  /**
   * è·å–é»˜è®¤å“åº”
   */
  static getDefaultResponse(): string {
    const htmlContent = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>HarmonyOS HTTP Server</title>
        <style>
          body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background-color: #f5f5f5;
          }
          h1 {
            color: #333;
            text-align: center;
          }
          .info {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
          }
        </style>
      </head>
      <body>
        <div class="info">
          <h1>HarmonyOS HTTP æœåŠ¡å™¨</h1>
          <p>æœåŠ¡å™¨è¿è¡Œæ­£å¸¸</p>
          <p>å½“å‰æ—¶é—´: ${new Date().toLocaleString('zh-CN')}</p>
        </div>
      </body>
      </html>
    `;

    const contentBuf = HttpServerHandler.textEncoder.encodeInto(htmlContent);

    return `HTTP/1.1 200 OK\r\n` +
           `Content-Type: text/html; charset=utf-8\r\n` +
           `Content-Length: ${contentBuf.length}\r\n` +
           `\r\n` +
           htmlContent;
  }

  /**
   * æ ¹æ®è¯·æ±‚è·¯å¾„å¤„ç†ä¸åŒçš„å“åº”
   * å¯ä»¥æ‰©å±•è¿™ä¸ªæ–¹æ³•æ¥å®ç°è·¯ç”±åŠŸèƒ½
   */
  static createRouterHandler(): HttpRequestHandler {
    return (rawRequest: string): string => {
      try {
        // å®‰å…¨åœ°æˆªå–è¯·æ±‚å†…å®¹ç”¨äºæ—¥å¿—
        const requestPreview = rawRequest && rawRequest.length > 0 
          ? rawRequest.substring(0, Math.min(200, rawRequest.length))
          : '(empty request)';
        hilog.info(DOMAIN, 'HttpServerHandler', `å¤„ç†è·¯ç”±è¯·æ±‚: ${requestPreview}...`);
        
        // æ£€æŸ¥è¯·æ±‚æ˜¯å¦ä¸ºç©º
        if (!rawRequest || rawRequest.trim().length === 0) {
          hilog.warn(DOMAIN, 'HttpServerHandler', 'æ”¶åˆ°ç©ºè¯·æ±‚');
          return HttpServerHandler.getNotFoundResponse();
        }
        
        // è§£æè¯·æ±‚è·¯å¾„
      const requestLines = rawRequest.split('\r\n');
        if (requestLines.length === 0) {
          hilog.warn(DOMAIN, 'HttpServerHandler', 'è¯·æ±‚æ ¼å¼æ— æ•ˆ');
          return HttpServerHandler.getNotFoundResponse();
        }
        
      const requestLine = requestLines[0] || '';
        const pathParts = requestLine.split(' ');
        const rawPath = pathParts.length > 1 ? pathParts[1] : '/';
        // æ‹†åˆ†è·¯å¾„ä¸æŸ¥è¯¢å‚æ•°ï¼ˆé¿å…è§£æ„å£°æ˜ï¼‰
        const qIndex = rawPath.indexOf('?');
        const path = qIndex >= 0 ? rawPath.substring(0, qIndex) : rawPath;
        const queryString = qIndex >= 0 ? rawPath.substring(qIndex + 1) : '';
        const params: Record<string, string> = {};
        if (queryString && queryString.length > 0) {
          const pairs = queryString.split('&');
          for (let i = 0; i < pairs.length; i++) {
            const kv = pairs[i].split('=');
            const k = decodeURIComponent(kv[0] || '');
            const v = decodeURIComponent(kv[1] || '');
            if (k) { params[k] = v; }
          }
        }
        
        // è§£æè·¯å¾„å‚æ•°ï¼ˆå¤„ç† URL ç¼–ç ï¼‰
        let decodedPath = path;
        try {
          decodedPath = decodeURIComponent(path);
        } catch (e) {
          // å¦‚æœè§£ç å¤±è´¥ï¼Œä½¿ç”¨åŸè·¯å¾„
          hilog.warn(DOMAIN, 'HttpServerHandler', `URLè§£ç å¤±è´¥: ${path}`);
        }
      
      // æ ¹æ®è·¯å¾„è¿”å›ä¸åŒå†…å®¹
      if (path === '/' || path === '/index') {
          return HttpServerHandler.getFileBrowserResponse(params);
      } else if (path === '/api/status') {
        return HttpServerHandler.getStatusResponse();
        } else if (path.startsWith('/files/') || path.startsWith('/file/')) {
          // æ–‡ä»¶æµè§ˆè·¯å¾„: /files/ æˆ– /file/ ï¼ˆæ”¯æŒä¸¤ç§è·¯å¾„ï¼‰
          // ç»Ÿä¸€å¤„ç†ï¼Œå»æ‰å‰ç¼€
          const filePath = decodedPath.replace(/^\/files?\//, '');
          if (filePath === '') {
            // æ˜¾ç¤ºæ–‡ä»¶åˆ—è¡¨
            return HttpServerHandler.getFileBrowserResponse(params);
          } else {
            // æ˜¾ç¤ºæˆ–ä¸‹è½½æ–‡ä»¶
            return HttpServerHandler.getFileResponse(filePath);
          }
      } else if (path.startsWith('/api/')) {
          // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦åŒ…å«æŸ¥è¯¢ä¸²ï¼Œå¦åˆ™ getApiResponse æ— æ³•è§£æ action ç­‰å‚æ•°
          return HttpServerHandler.getApiResponse(rawPath);
      } else {
        return HttpServerHandler.getNotFoundResponse();
        }
      } catch (error) {
        // æ•è·æ‰€æœ‰å¼‚å¸¸ï¼Œé˜²æ­¢å´©æºƒ
        hilog.error(DOMAIN, 'HttpServerHandler', `è·¯ç”±å¤„ç†å¼‚å¸¸: ${JSON.stringify(error)}`);
        try {
          return HttpServerHandler.getNotFoundResponse();
        } catch (e) {
          // å¦‚æœè¿ 404 å“åº”éƒ½æ— æ³•ç”Ÿæˆï¼Œè¿”å›æœ€åŸºæœ¬çš„é”™è¯¯å“åº”
          hilog.error(DOMAIN, 'HttpServerHandler', `æ— æ³•ç”Ÿæˆé”™è¯¯å“åº”: ${JSON.stringify(e)}`);
          return 'HTTP/1.1 500 Internal Server Error\r\n\r\n';
        }
      }
    };
  }

  /**
   * çŠ¶æ€APIå“åº”
   */
  static getStatusResponse(): string {
    const jsonContent = JSON.stringify({
      status: 'ok',
      timestamp: new Date().toISOString(),
      server: 'HarmonyOS HTTP Server'
    });
    const jsonBuf = HttpServerHandler.textEncoder.encodeInto(jsonContent);
    return `HTTP/1.1 200 OK\r\n` +
           `Content-Type: application/json; charset=utf-8\r\n` +
           `Content-Length: ${jsonBuf.length}\r\n` +
           `\r\n` +
           jsonContent;
  }

  /**
   * APIå“åº”å¤„ç†
   */
  static getApiResponse(path: string): string {
    // /api/processing?action=listJson|insert|update|delete
    if (path.indexOf('/api/processing') === 0) {
      try {
        const idx = path.indexOf('?');
        const queryString = idx >= 0 ? path.substring(idx + 1) : '';
        const params: Record<string, string> = {};
        if (queryString) {
          const pairs = queryString.split('&');
          for (let i = 0; i < pairs.length; i++) {
            const kv = pairs[i].split('=');
            const k = decodeURIComponent(kv[0] || '');
            const v = decodeURIComponent(kv[1] || '');
            if (k) { params[k] = v; }
          }
        }

        const action = params['action'] || 'listJson';
        // é¦–æ¬¡è®¿é—®æ—¶åŠ è½½ç¼“å­˜
        if (!HttpServerHandler.processingCacheLoaded) {
          try {
            ArkDataDemoService.createProcessingHistoryTable().then(() => {
              ArkDataDemoService.queryAllProcessing().then((rows) => {
                HttpServerHandler.processingCache = rows;
                HttpServerHandler.processingCacheLoaded = true;
              }, () => {});
            }, () => {});
          } catch (_) {}
        }

        if (action === 'listJson') {
          if (!HttpServerHandler.processingCacheLoaded) {
            HttpServerHandler.loadProcessingCacheFromDisk();
          }
          const src = HttpServerHandler.processingCache || [];
          // å…¼å®¹æ—§æ•°æ®ï¼šå¡«å……ç¼ºå¤±å­—æ®µï¼Œé¿å…å‰ç«¯æ˜¾ç¤ºä¸ºç©º
          const data: ProcessingRow[] = [];
          for (let i = 0; i < src.length; i++) {
            const r = src[i];
            const norm: ProcessingRow = {
              id: r.id,
              startTime: r.startTime,
              endTime: r.endTime,
              productType: r.productType,
              totalWeight: r.totalWeight,
              customerName: r.customerName || '',
              farmName: r.farmName || '',
              fruitName: r.fruitName || r.productType || '',
              status: r.status || '',
              count: (typeof r.count === 'number') ? r.count : 0,
              weight: (typeof r.weight === 'number') ? r.weight : (r.totalWeight || 0)
            };
            data.push(norm);
          }
          const json = JSON.stringify({ ok: true, data });
          const buf = HttpServerHandler.textEncoder.encodeInto(json);
          return `HTTP/1.1 200 OK\r\nContent-Type: application/json; charset=utf-8\r\nContent-Length: ${buf.length}\r\n\r\n${json}`;
        } else if (action === 'insert') {
          const startTime = params['startTime'] || '';
          const endTime = params['endTime'] || '';
          const productType = params['productType'] || '';
          const totalWeight = Number(params['totalWeight'] || '0');
          // æ–°å¢æ‰©å±•å­—æ®µï¼ˆä»…ç¼“å­˜/é¡µé¢æ˜¾ç¤ºï¼‰
          const customerName = params['customerName'] || '';
          const farmName = params['farmName'] || '';
          const fruitName = params['fruitName'] || productType;
          const status = params['status'] || '';
          const count = Number(params['count'] || '0');
          const weight = Number(params['weight'] || totalWeight || '0');
          // å‚æ•°æ ¡éªŒï¼šéç©ºä¸æ—¶é—´å…ˆå
          if (!startTime || !endTime || !fruitName || !(params['totalWeight'] || params['weight'] || '').toString().length) {
            const errJson = JSON.stringify({ ok: false, message: 'å‚æ•°ä¸èƒ½ä¸ºç©º' });
            const errBuf = HttpServerHandler.textEncoder.encodeInto(errJson);
            return `HTTP/1.1 400 Bad Request\r\nContent-Type: application/json; charset=utf-8\r\nContent-Length: ${errBuf.length}\r\n\r\n${errJson}`;
          }
          // å°è¯•æ¯”è¾ƒæ—¶é—´
          let invalidOrder = false;
          try {
            const sNum = Date.parse(startTime);
            const eNum = Date.parse(endTime);
            if (!isNaN(sNum) && !isNaN(eNum) && sNum > eNum) {
              invalidOrder = true;
            }
          } catch (_) {}
          if (invalidOrder) {
            const errJson = JSON.stringify({ ok: false, message: 'å¼€å§‹æ—¶é—´ä¸èƒ½æ™šäºç»“æŸæ—¶é—´' });
            const errBuf = HttpServerHandler.textEncoder.encodeInto(errJson);
            return `HTTP/1.1 400 Bad Request\r\nContent-Type: application/json; charset=utf-8\r\nContent-Length: ${errBuf.length}\r\n\r\n${errJson}`;
          }
          // å…ˆæ›´æ–°å†…å­˜ç¼“å­˜ï¼Œä¿è¯å‰ç«¯ç«‹å³å¯è§
          try {
            // ç”Ÿæˆä¸€ä¸ªæ›´è´´è¿‘ä¸šåŠ¡çš„ä¸´æ—¶IDï¼šå–å½“å‰ç¼“å­˜æœ€å¤§ID+1ï¼ˆè‹¥æ— åˆ™ä¸º1ï¼‰
            let nextId = 1;
            try {
              const listForId = HttpServerHandler.processingCache || [];
              for (let i = 0; i < listForId.length; i++) {
                const cid = listForId[i] && typeof listForId[i].id === 'number' ? listForId[i].id : 0;
                if (cid >= nextId) { nextId = cid + 1; }
              }
            } catch (_) {}
            const tmpRow: ProcessingRow = { id: nextId, startTime, endTime, productType, totalWeight, customerName, farmName, fruitName, status, count, weight };
            if (!HttpServerHandler.processingCache) { HttpServerHandler.processingCache = []; }
            HttpServerHandler.processingCache.unshift(tmpRow);
            HttpServerHandler.processingCacheLoaded = true;
          } catch (_) {}
          try {
            const payload: ProcessingInsertParams = {
              startTime: startTime,
              endTime: endTime,
              productType: productType,
              totalWeight: totalWeight,
              customerName: customerName,
              farmName: farmName,
              fruitName: fruitName,
              status: status,
              count: count,
              weight: weight
            };
            ArkDataDemoService.insertProcessingFull(payload).then(() => {
              ArkDataDemoService.queryAllProcessing().then((rows) => {
                HttpServerHandler.processingCache = rows;
                HttpServerHandler.processingCacheLoaded = true;
                HttpServerHandler.saveProcessingCacheToDisk();
              }, () => {});
            }, () => {});
          } catch (_) {}
          // ç«‹å³æŠŠå½“å‰å†…å­˜åˆ—è¡¨è¿”å›ï¼Œä¾¿äºå‰ç«¯æ— éœ€ç­‰å¾…ç¼“å­˜åˆ·æ–°
          HttpServerHandler.saveProcessingCacheToDisk();
          const json = JSON.stringify({ ok: true, data: HttpServerHandler.processingCache || [] });
          const buf = HttpServerHandler.textEncoder.encodeInto(json);
          return `HTTP/1.1 200 OK\r\nContent-Type: application/json; charset=utf-8\r\nContent-Length: ${buf.length}\r\n\r\n${json}`;
        } else if (action === 'update') {
          const id = Number(params['id'] || '0');
          const startTime = params['startTime'] || '';
          const endTime = params['endTime'] || '';
          const productType = params['productType'] || '';
          const totalWeight = Number(params['totalWeight'] || '0');
          // å…ˆæ›´æ–°å†…å­˜ç¼“å­˜
          try {
            const list = HttpServerHandler.processingCache || [];
            for (let i = 0; i < list.length; i++) {
              if (list[i].id === id) {
                list[i] = { id, startTime, endTime, productType, totalWeight };
                break;
              }
            }
            HttpServerHandler.processingCache = list;
            HttpServerHandler.processingCacheLoaded = true;
          } catch (_) {}
          try {
            ArkDataDemoService.updateProcessingById(id, startTime, endTime, productType, totalWeight).then(() => {
              ArkDataDemoService.queryAllProcessing().then((rows) => {
                HttpServerHandler.processingCache = rows;
                HttpServerHandler.processingCacheLoaded = true;
                HttpServerHandler.saveProcessingCacheToDisk();
              }, () => {});
            }, () => {});
          } catch (_) {}
          HttpServerHandler.saveProcessingCacheToDisk();
          const json = JSON.stringify({ ok: true, data: HttpServerHandler.processingCache || [] });
          const buf = HttpServerHandler.textEncoder.encodeInto(json);
          return `HTTP/1.1 200 OK\r\nContent-Type: application/json; charset=utf-8\r\nContent-Length: ${buf.length}\r\n\r\n${json}`;
        } else if (action === 'delete') {
          const id = Number(params['id'] || '0');
          // å…ˆæ›´æ–°å†…å­˜ç¼“å­˜
          try {
            const list = HttpServerHandler.processingCache || [];
            const next: ProcessingRow[] = [];
            for (let i = 0; i < list.length; i++) {
              if (list[i].id !== id) { next.push(list[i]); }
            }
            HttpServerHandler.processingCache = next;
            HttpServerHandler.processingCacheLoaded = true;
          } catch (_) {}
          try {
            ArkDataDemoService.deleteProcessingById(id).then(() => {
              ArkDataDemoService.queryAllProcessing().then((rows) => {
                HttpServerHandler.processingCache = rows;
                HttpServerHandler.processingCacheLoaded = true;
                HttpServerHandler.saveProcessingCacheToDisk();
              }, () => {});
            }, () => {});
          } catch (_) {}
          HttpServerHandler.saveProcessingCacheToDisk();
          const json = JSON.stringify({ ok: true, data: HttpServerHandler.processingCache || [] });
          const buf = HttpServerHandler.textEncoder.encodeInto(json);
          return `HTTP/1.1 200 OK\r\nContent-Type: application/json; charset=utf-8\r\nContent-Length: ${buf.length}\r\n\r\n${json}`;
        }
      } catch (e) {
        const json = JSON.stringify({ ok: false });
        const buf = HttpServerHandler.textEncoder.encodeInto(json);
        return `HTTP/1.1 500 Internal Server Error\r\nContent-Type: application/json; charset=utf-8\r\nContent-Length: ${buf.length}\r\n\r\n${json}`;
      }
    }
    // é»˜è®¤å ä½
    const jsonContent2 = JSON.stringify({
      path: path,
      message: 'API endpoint',
      data: null
    });
    const jsonBuf2 = HttpServerHandler.textEncoder.encodeInto(jsonContent2);
    return `HTTP/1.1 200 OK\r\n` +
           `Content-Type: application/json; charset=utf-8\r\n` +
           `Content-Length: ${jsonBuf2.length}\r\n` +
           `\r\n` +
           jsonContent2;
  }

  /**
   * æ–‡ä»¶æµè§ˆå™¨å“åº”ï¼ˆæ˜¾ç¤ºæ–‡ä»¶åˆ—è¡¨ï¼Œç±»ä¼¼ Jupyter Notebookï¼‰
   */
  static getFileBrowserResponse(params?: Record<string, string>): string {
    if (!HttpServerHandler.fileBasePath) {
      return HttpServerHandler.getNotFoundResponse();
    }

    try {
      // æ ¹ç›®å½•é¡µï¼šå±•ç¤ºåŸºç¡€è·¯å¾„ä¸‹çš„ç¬¬ä¸€å±‚ç›®å½•ï¼ˆåŒ…å« fileï¼‰
      const targetDir = `${HttpServerHandler.fileBasePath}`;
      
      hilog.info(DOMAIN, 'HttpServerHandler', `æ–‡ä»¶æµè§ˆå™¨è®¿é—®ç›®å½•(æ ¹): ${targetDir}`);
      console.log(`HTTPæœåŠ¡å™¨æ–‡ä»¶æµè§ˆå™¨è®¿é—®ç›®å½•(æ ¹): ${targetDir}`);
      
      // åˆ—å‡ºç›®å½•ä¸­çš„æ‰€æœ‰æ–‡ä»¶å’Œæ–‡ä»¶å¤¹
      const items: FileItem[] = [];
      // åˆ†é¡µå±•ç¤ºè¾…åŠ©å˜é‡ï¼ˆéœ€åœ¨å¤–å±‚å£°æ˜ï¼Œæ¨¡æ¿ä¸­ä½¿ç”¨ï¼‰
      let prevHtml: string = '<span>ä¸Šä¸€é¡µ</span>';
      let pageLabelHtml: string = '<span>ç¬¬ 1 é¡µ</span>';
      let nextHtml: string = '<span>ä¸‹ä¸€é¡µ</span>';
      
      try {
        const files = fs.listFileSync(targetDir);
        // åˆ†é¡µå‚æ•°
        const pageSize = Math.max(1, Math.min(200, Number(params && params['pageSize'] ? params['pageSize'] : '50') || 50));
        const page = Math.max(1, Number(params && params['page'] ? params['page'] : '1') || 1);
        const total = files.length;
        const totalPages = Math.max(1, Math.ceil(total / pageSize));
        const start = (page - 1) * pageSize;
        const end = Math.min(total, start + pageSize);
        const filesToProcess = files.slice(start, end);
        // é¢„ç”Ÿæˆåˆ†é¡µHTMLï¼ˆå¤–å±‚å·²å£°æ˜ï¼Œè¿™é‡Œåªèµ‹å€¼ï¼‰
        const prevPage = page > 1 ? page - 1 : 1;
        const nextPage = page < totalPages ? page + 1 : totalPages;
        prevHtml = page > 1 ? `<a href="/files/?page=${prevPage}&pageSize=${pageSize}">ä¸Šä¸€é¡µ</a>` : '<span>ä¸Šä¸€é¡µ</span>';
        pageLabelHtml = `<span>ç¬¬ ${page} é¡µ / å…± ${totalPages} é¡µ</span>`;
        nextHtml = page < totalPages ? `<a href="/files/?page=${nextPage}&pageSize=${pageSize}">ä¸‹ä¸€é¡µ</a>` : '<span>ä¸‹ä¸€é¡µ</span>';
        
        for (let i = 0; i < filesToProcess.length; i++) {
          const fileName = files[i];
          const fullPath = `${targetDir}/${fileName}`;
          
          try {
            const stat = fs.statSync(fullPath);
            const item: FileItem = {
              name: fileName,
              isDir: stat.isDirectory(),
              path: fileName
            };
            items.push(item);
          } catch (e) {
            hilog.warn(DOMAIN, 'HttpServerHandler', 'Cannot access: %{public}s', fullPath);
          }
        }
        
        // åˆ†é¡µä¿¡æ¯æ—¥å¿—ï¼ˆå¯é€‰ï¼‰
        hilog.info(DOMAIN, 'HttpServerHandler', `åˆ†é¡µ: page=${page}, pageSize=${pageSize}, total=${total}`);
      } catch (error) {
        hilog.error(DOMAIN, 'HttpServerHandler', `Failed to list directory: ${JSON.stringify(error)}`);
      }

      // ç”Ÿæˆ HTML æ–‡ä»¶åˆ—è¡¨
      let fileListHtml = '';
      if (items.length === 0) {
        fileListHtml = '<p style="color: #999; padding: 20px;">ç›®å½•ä¸ºç©º</p>';
      } else {
        // å…ˆæ˜¾ç¤ºæ–‡ä»¶å¤¹ï¼Œå†æ˜¾ç¤ºæ–‡ä»¶
        const dirs = items.filter(item => item.isDir).sort((a, b) => a.name.localeCompare(b.name));
        const files = items.filter(item => !item.isDir).sort((a, b) => a.name.localeCompare(b.name));
        
        [...dirs, ...files].forEach(item => {
          const icon = item.isDir ? 'ğŸ“' : 'ğŸ“„';
          const encodedPath = encodeURIComponent(item.path);
          // ä½¿ç”¨å®Œæ•´çš„URLè·¯å¾„ï¼Œç¡®ä¿æµè§ˆå™¨åœ°å€æ æ­£ç¡®æ›´æ–°
          fileListHtml += `
            <div class="file-item" onclick="window.location.href='http://' + window.location.host + '/files/${encodedPath}'">
              <span class="file-icon">${icon}</span>
              <span class="file-name">${HttpServerHandler.escapeHtml(item.name)}</span>
              ${item.isDir ? '<span class="file-type">ç›®å½•</span>' : '<span class="file-type">æ–‡ä»¶</span>'}
            </div>
          `;
        });
      }

      const htmlContent = `
        <!DOCTYPE html>
        <html lang="zh-CN">
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>æ–‡ä»¶æµè§ˆå™¨ - HarmonyOS</title>
          <style>
            * {
              margin: 0;
              padding: 0;
              box-sizing: border-box;
            }
            body {
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              min-height: 100vh;
              padding: 20px;
            }
            .container {
              max-width: 900px;
              margin: 0 auto;
              background: white;
              border-radius: 12px;
              box-shadow: 0 10px 40px rgba(0,0,0,0.2);
              overflow: hidden;
            }
            .header {
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              color: white;
              padding: 30px;
              text-align: center;
            }
            .header h1 {
              font-size: 28px;
              margin-bottom: 10px;
            }
            .header p {
              opacity: 0.9;
              font-size: 14px;
            }
            .file-browser {
              padding: 30px;
            }
            .quick-links { display:flex; gap:10px; margin-bottom: 16px; }
            .quick-links a { color:#fff; background:#667eea; padding:8px 12px; border-radius:6px; text-decoration:none; }
            .quick-links a:hover { background:#556cdf; }
            .path-info {
              background: #f8f9fa;
              padding: 15px;
              border-radius: 8px;
              margin-bottom: 20px;
              font-family: monospace;
              color: #495057;
              font-size: 14px;
            }
            .file-item {
              display: flex;
              align-items: center;
              padding: 15px;
              margin: 8px 0;
              background: #f8f9fa;
              border-radius: 8px;
              cursor: pointer;
              transition: all 0.2s;
              border: 2px solid transparent;
            }
            .file-item:hover {
              background: #e9ecef;
              border-color: #667eea;
              transform: translateX(5px);
            }
            .file-icon {
              font-size: 24px;
              margin-right: 15px;
              width: 30px;
              text-align: center;
            }
            .file-name {
              flex: 1;
              font-size: 16px;
              color: #212529;
              font-weight: 500;
            }
            .file-type {
              background: #667eea;
              color: white;
              padding: 4px 12px;
              border-radius: 12px;
              font-size: 12px;
              font-weight: 500;
            }
            .empty-message {
              text-align: center;
              padding: 60px 20px;
              color: #6c757d;
            }
            .pagination { display: flex; justify-content: space-between; margin: 20px 0; }
            .pagination a { color: #667eea; text-decoration: none; padding: 8px 12px; background: #f0f0ff; border-radius: 6px; }
            .pagination span { color: #666; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <h1>ğŸ“‚ æ–‡ä»¶æµè§ˆå™¨</h1>
              <p>HarmonyOS HTTP æœåŠ¡å™¨æ–‡ä»¶ç®¡ç†</p>
            </div>
            <div class="file-browser">
              <div class="quick-links">
                <a href="/files/file/processing.html">åŠ å·¥å†å²ç®¡ç†</a>
              </div>
              <div class="path-info">
                å½“å‰ä½ç½®: ${HttpServerHandler.buildBreadcrumb('')}
              </div>
              <div class="pagination">
                <div>${prevHtml}</div>
                <div>${pageLabelHtml}</div>
                <div>${nextHtml}</div>
              </div>
              <div class="file-list">
                ${fileListHtml}
              </div>
            </div>
          </div>
        </body>
        </html>
      `;

      const contentBuf = HttpServerHandler.textEncoder.encodeInto(htmlContent);

    return `HTTP/1.1 200 OK\r\n` +
             `Content-Type: text/html; charset=utf-8\r\n` +
             `Content-Length: ${contentBuf.length}\r\n` +
           `\r\n` +
             htmlContent;
    } catch (error) {
      hilog.error(DOMAIN, 'HttpServerHandler', `æ–‡ä»¶æµè§ˆå™¨é”™è¯¯: ${JSON.stringify(error)}`);
      return HttpServerHandler.getNotFoundResponse();
    }
  }

  /**
   * æ–‡ä»¶å“åº”ï¼ˆæ˜¾ç¤ºæˆ–ä¸‹è½½æ–‡ä»¶å†…å®¹ï¼‰
   * æ³¨æ„ï¼šæ–‡ä»¶å¤§å°é™åˆ¶ä¸º 5MBï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹
   */
  static getFileResponse(relativePath: string): string {
    if (!HttpServerHandler.fileBasePath) {
      return HttpServerHandler.getNotFoundResponse();
    }

    try {
      const fullPath = `${HttpServerHandler.fileBasePath}/${relativePath}`;
      
      // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
      if (!fs.accessSync(fullPath)) {
        return HttpServerHandler.getNotFoundResponse();
      }

      const stat = fs.statSync(fullPath);
      
      // é™åˆ¶æ–‡ä»¶å¤§å°ï¼šæœ€å¤§ 5MBï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹
      const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
      if (stat.isFile() && stat.size > MAX_FILE_SIZE) {
        hilog.warn(DOMAIN, 'HttpServerHandler', `æ–‡ä»¶è¿‡å¤§ï¼Œå·²è·³è¿‡: ${fullPath} (${stat.size} bytes)`);
        return `HTTP/1.1 413 Payload Too Large\r\nContent-Type: text/plain\r\n\r\næ–‡ä»¶è¿‡å¤§ï¼ˆè¶…è¿‡ 5MBï¼‰ï¼Œæ— æ³•é€šè¿‡ HTTP æœåŠ¡å™¨é¢„è§ˆã€‚`;
      }
      
      // å¦‚æœæ˜¯ç›®å½•ï¼Œæ˜¾ç¤ºç›®å½•å†…å®¹
      if (stat.isDirectory()) {
        const items: FileItem[] = [];
        try {
          const files = fs.listFileSync(fullPath);
          
          // é™åˆ¶ç›®å½•æ–‡ä»¶æ•°é‡ï¼šæœ€å¤šå¤„ç† 100 ä¸ªæ–‡ä»¶ï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹
          const MAX_FILES = 100;
          const filesToProcess = files.length > MAX_FILES ? files.slice(0, MAX_FILES) : files;
          
          for (let i = 0; i < filesToProcess.length; i++) {
            const fileName = filesToProcess[i];
            const itemPath = `${fullPath}/${fileName}`;
            try {
              const itemStat = fs.statSync(itemPath);
              const item: FileItem = {
                name: fileName,
                isDir: itemStat.isDirectory(),
                path: `${relativePath}/${fileName}`
              };
              items.push(item);
            } catch (e) {
              // å¿½ç•¥æ— æ³•è®¿é—®çš„æ–‡ä»¶
            }
            
            // æ¯å¤„ç† 10 ä¸ªæ–‡ä»¶åï¼Œè®©å‡ºä¸»çº¿ç¨‹ï¼ˆä½¿ç”¨ setTimeout å»¶è¿Ÿï¼‰
            if (i > 0 && i % 10 === 0) {
              // æ³¨æ„ï¼šè¿™é‡Œä¸èƒ½çœŸæ­£å¼‚æ­¥ï¼Œä½†å¯ä»¥å‡å°‘è¿ç»­é˜»å¡
            }
          }
          
          if (files.length > MAX_FILES) {
            hilog.warn(DOMAIN, 'HttpServerHandler', `ç›®å½•æ–‡ä»¶è¿‡å¤šï¼ˆ${files.length}ï¼‰ï¼Œä»…æ˜¾ç¤ºå‰ ${MAX_FILES} ä¸ª`);
          }
        } catch (e) {
          // å¿½ç•¥é”™è¯¯
        }

        // ç”Ÿæˆç›®å½•åˆ—è¡¨ HTMLï¼ˆç±»ä¼¼æ–‡ä»¶æµè§ˆå™¨ï¼‰
        let fileListHtml = '';
        const dirs = items.filter(item => item.isDir).sort((a, b) => a.name.localeCompare(b.name));
        const files = items.filter(item => !item.isDir).sort((a, b) => a.name.localeCompare(b.name));
        
        [...dirs, ...files].forEach(item => {
          const icon = item.isDir ? 'ğŸ“' : 'ğŸ“„';
          const encodedPath = encodeURIComponent(item.path);
          // ä½¿ç”¨å®Œæ•´çš„URLè·¯å¾„ï¼Œç¡®ä¿æµè§ˆå™¨åœ°å€æ æ­£ç¡®æ›´æ–°
          fileListHtml += `
            <div class="file-item" onclick="window.location.href='http://' + window.location.host + '/files/${encodedPath}'">
              <span class="file-icon">${icon}</span>
              <span class="file-name">${HttpServerHandler.escapeHtml(item.name)}</span>
              ${item.isDir ? '<span class="file-type">ç›®å½•</span>' : '<span class="file-type">æ–‡ä»¶</span>'}
            </div>
          `;
        });

        const htmlContent = `
          <!DOCTYPE html>
          <html lang="zh-CN">
          <head>
            <meta charset="utf-8">
            <title>${HttpServerHandler.escapeHtml(relativePath)} - æ–‡ä»¶æµè§ˆå™¨</title>
            <style>
              * { margin: 0; padding: 0; box-sizing: border-box; }
              body { font-family: Arial, sans-serif; background: #f5f5f5; padding: 20px; }
              .container { max-width: 900px; margin: 0 auto; background: white; border-radius: 8px; padding: 20px; }
              .path-info { background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 20px; font-family: monospace; }
              .file-item { display: flex; align-items: center; padding: 10px; margin: 5px 0; background: #f8f9fa; border-radius: 4px; cursor: pointer; }
              .file-item:hover { background: #e9ecef; }
              .file-icon { font-size: 20px; margin-right: 10px; }
              .file-name { flex: 1; }
              .file-type { background: #667eea; color: white; padding: 2px 8px; border-radius: 4px; font-size: 12px; }
            </style>
          </head>
          <body>
            <div class="container">
              <div class="path-info">å½“å‰ä½ç½®: ${HttpServerHandler.buildBreadcrumb(relativePath)}</div>
              <div class="file-list">${fileListHtml}</div>
            </div>
          </body>
          </html>
        `;

        const contentBuf = HttpServerHandler.textEncoder.encodeInto(htmlContent);
        return `HTTP/1.1 200 OK\r\nContent-Type: text/html; charset=utf-8\r\nContent-Length: ${contentBuf.length}\r\n\r\n${htmlContent}`;
      }

      // è¯»å–æ–‡ä»¶å†…å®¹
      const file = fs.openSync(fullPath, fs.OpenMode.READ_ONLY);
      const fileSize = stat.size;
      const buffer = new ArrayBuffer(fileSize);
      fs.readSync(file.fd, buffer);
      fs.closeSync(file.fd);

      // åˆ¤æ–­æ–‡ä»¶ç±»å‹
      const fileExt = relativePath.split('.').pop()?.toLowerCase() || '';
      let contentType = 'text/plain';
      let shouldDisplay = true;

      if (fileExt === 'html' || fileExt === 'htm') {
        contentType = 'text/html';
      } else if (fileExt === 'css') {
        contentType = 'text/css';
      } else if (fileExt === 'js') {
        contentType = 'application/javascript';
      } else if (fileExt === 'json') {
        contentType = 'application/json';
      } else if (fileExt === 'png' || fileExt === 'jpg' || fileExt === 'jpeg' || fileExt === 'gif') {
        contentType = `image/${fileExt === 'jpg' ? 'jpeg' : fileExt}`;
        shouldDisplay = false;
      } else if (fileExt === 'txt') {
        contentType = 'text/plain; charset=utf-8';
      } else {
        shouldDisplay = false;
      }

      // è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼ˆæ–‡æœ¬æ–‡ä»¶ï¼‰
      if (shouldDisplay && (contentType.startsWith('text/') || contentType.includes('json') || contentType.includes('javascript'))) {
        // æ–‡æœ¬é¢„è§ˆå¤§å°é™åˆ¶ï¼ˆé¿å…ä¸€æ¬¡æ€§æ¸²æŸ“è¶…å¤§æ–‡æœ¬é€ æˆå¡é¡¿ï¼‰
        const TEXT_PREVIEW_LIMIT = 256 * 1024; // 256KB
        if (fileSize > TEXT_PREVIEW_LIMIT) {
          // è¶…è¿‡é™åˆ¶ç›´æ¥æä¾›ä¸‹è½½
          const uint8ArrayAll = new Uint8Array(buffer);
          let binaryStringAll = '';
          for (let i = 0; i < uint8ArrayAll.length; i++) {
            binaryStringAll += String.fromCharCode(uint8ArrayAll[i]);
          }
          return `HTTP/1.1 200 OK\r\nContent-Type: ${contentType}; charset=utf-8\r\nContent-Disposition: attachment; filename="${encodeURIComponent(relativePath.split('/').pop() || 'text')}"\r\nContent-Length: ${fileSize}\r\n\r\n${binaryStringAll}`;
        }
        const uint8Array = new Uint8Array(buffer);
        const textContent = HttpServerHandler.textDecoder.decode(uint8Array);
        
        // å¦‚æœæ˜¯ HTML æ–‡ä»¶ï¼Œç›´æ¥è¿”å›åŸå§‹ HTML å†…å®¹è®©æµè§ˆå™¨æ¸²æŸ“
        if (fileExt === 'html' || fileExt === 'htm') {
          const contentBuf = HttpServerHandler.textEncoder.encodeInto(textContent);
          return `HTTP/1.1 200 OK\r\nContent-Type: text/html; charset=utf-8\r\nContent-Length: ${contentBuf.length}\r\n\r\n${textContent}`;
        }
        
        // å…¶ä»–æ–‡æœ¬æ–‡ä»¶ï¼ˆtxt, css, js, jsonï¼‰æ˜¾ç¤ºä¸ºä»£ç é¢„è§ˆ
        const htmlContent = `
          <!DOCTYPE html>
          <html lang="zh-CN">
          <head>
            <meta charset="utf-8">
            <title>${HttpServerHandler.escapeHtml(relativePath)}</title>
            <style>
              body { font-family: 'Courier New', monospace; padding: 20px; background: #1e1e1e; color: #d4d4d4; }
              .header { margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid #444; }
              .header h1 { color: #fff; margin-bottom: 5px; }
              .file-path { color: #999; font-size: 12px; }
              pre { background: #252526; padding: 15px; border-radius: 4px; overflow-x: auto; }
            </style>
          </head>
          <body>
            <div class="header">
              <h1>ğŸ“„ ${HttpServerHandler.escapeHtml(relativePath)}</h1>
              <div class="file-path">${HttpServerHandler.escapeHtml(fullPath)}</div>
            </div>
            <pre>${HttpServerHandler.escapeHtml(textContent)}</pre>
          </body>
          </html>
        `;

        const contentBuf = HttpServerHandler.textEncoder.encodeInto(htmlContent);
        return `HTTP/1.1 200 OK\r\nContent-Type: text/html; charset=utf-8\r\nContent-Length: ${contentBuf.length}\r\n\r\n${htmlContent}`;
      } else {
        // äºŒè¿›åˆ¶æ–‡ä»¶æˆ–å›¾ç‰‡
        const uint8Array = new Uint8Array(buffer);
        const EMBED_IMAGE_LIMIT = 512 * 1024; // 512KB
        
        if (contentType.startsWith('image/')) {
          // å¤§å›¾ç›´æ¥ä¸‹è½½ï¼Œå°å›¾å†…åµŒæ˜¾ç¤º
          if (fileSize > EMBED_IMAGE_LIMIT) {
            let binaryString = '';
            for (let i = 0; i < uint8Array.length; i++) {
              binaryString += String.fromCharCode(uint8Array[i]);
            }
            return `HTTP/1.1 200 OK\r\nContent-Type: ${contentType}\r\nContent-Disposition: attachment; filename="${encodeURIComponent(relativePath.split('/').pop() || 'image')}"\r\nContent-Length: ${fileSize}\r\n\r\n${binaryString}`;
          }
          const dataUrl = `data:${contentType};base64,${HttpServerHandler.toBase64(uint8Array)}`;
          const htmlContent = `
            <!DOCTYPE html>
            <html>
            <head>
              <meta charset="utf-8">
              <title>${HttpServerHandler.escapeHtml(relativePath)}</title>
              <style>
                body { text-align: center; padding: 20px; background: #f5f5f5; }
                img { max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); }
              </style>
            </head>
            <body>
              <h2>${HttpServerHandler.escapeHtml(relativePath)}</h2>
              <img src="${dataUrl}" alt="${HttpServerHandler.escapeHtml(relativePath)}">
            </body>
            </html>
          `;
          const contentBuf = HttpServerHandler.textEncoder.encodeInto(htmlContent);
          return `HTTP/1.1 200 OK\r\nContent-Type: text/html; charset=utf-8\r\nContent-Length: ${contentBuf.length}\r\n\r\n${htmlContent}`;
        } else {
          // å…¶ä»–äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œæä¾›ä¸‹è½½
          // å°† Uint8Array è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼ˆç”¨äºäºŒè¿›åˆ¶æ•°æ®ï¼‰
          let binaryString = '';
          for (let i = 0; i < uint8Array.length; i++) {
            binaryString += String.fromCharCode(uint8Array[i]);
          }
          return `HTTP/1.1 200 OK\r\nContent-Type: ${contentType}\r\nContent-Disposition: attachment; filename="${encodeURIComponent(relativePath.split('/').pop() || 'file')}"\r\nContent-Length: ${fileSize}\r\n\r\n${binaryString}`;
        }
      }
    } catch (error) {
      hilog.error(DOMAIN, 'HttpServerHandler', `æ–‡ä»¶è¯»å–é”™è¯¯: ${JSON.stringify(error)}`);
      return HttpServerHandler.getNotFoundResponse();
    }
  }

  /**
   * HTML è½¬ä¹‰
   */
  private static escapeHtml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  /**
   * æ„å»ºé¢åŒ…å±‘å¯¼èˆª HTML
   * relativePath ä¾‹å¦‚ "", "logs", "logs/2025-11"
   */
  static buildBreadcrumb(relativePath: string): string {
    // æ ¹
    if (!relativePath || relativePath.trim().length === 0) {
      return `<a href="/files/">é¦–é¡µ</a>`;
    }
    const safe = relativePath.replace(/^\/+|\/+$/g, '');
    const parts = safe.split('/');
    let acc = '';
    let html = `<a href="/files/">é¦–é¡µ</a>`;
    for (let i = 0; i < parts.length; i++) {
      const name = parts[i];
      acc = acc ? (acc + '/' + name) : name;
      const href = '/files/' + encodeURIComponent(acc);
      if (i < parts.length - 1) {
        html += ` / <a href="${href}">${HttpServerHandler.escapeHtml(name)}</a>`;
      } else {
        html += ` / <span>${HttpServerHandler.escapeHtml(name)}</span>`;
      }
    }
    return html;
  }

  /**
   * 404å“åº”
   */
  static getNotFoundResponse(): string {
    const htmlContent = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>404 Not Found</title>
      </head>
      <body>
        <h1>404</h1>
        <p>é¡µé¢æœªæ‰¾åˆ°</p>
      </body>
      </html>
    `;

    return `HTTP/1.1 404 Not Found\r\n` +
           `Content-Type: text/html; charset=utf-8\r\n` +
           `Content-Length: ${htmlContent.length}\r\n` +
           `\r\n` +
           htmlContent;
  }
}

