# HarmonyOS 数据库系统文档

## 文档说明

本文档全面介绍了HarmonyOS应用中的数据库系统，包括架构设计、使用方法、API接口和最佳实践等内容。本系统基于IBest-ORM框架实现，支持完整的CRUD操作和事务处理。

## 目录

1. [数据库架构概述](#数据库架构概述)
2. [数据模型设计](#数据模型设计)
3. [数据库初始化](#数据库初始化)
4. [数据库管理器使用指南](#数据库管理器使用指南)
5. [事务处理](#事务处理)
6. [HTTP API接口](#http-api接口)
7. [常见问题与解决方案](#常见问题与解决方案)
8. [最佳实践](#最佳实践)
9. [附录：代码示例](#附录代码示例)

## 数据库架构概述

### 1. 技术选型

- **ORM框架**：IBest-ORM（HarmonyOS专用）
- **底层存储**：ArkData关系存储
- **设计模式**：单例模式
- **支持模型**：User、TestModel、ProcessingHistory

### 2. 核心文件结构

```
entry/src/main/ets/database/
├── DatabaseManager.ets       # 数据库管理器（核心）
├── types.ets                 # 数据类型定义
├── index.ets                 # 模块统一导出
├── models/                   # 数据模型（表结构）
│   ├── User.ets              # 用户模型
│   ├── TestModel.ets         # 测试模型
│   └── ProcessingHistory.ets # 历史加工模型
└── utils/                    # 工具函数
    ├── TableNameMapper.ets   # 表名映射
    └── ...
```

## 数据模型设计

### 1. User模型

```typescript
@Table
export class User extends Model {
  @Field({ type: FieldType.TEXT })  // 文本类型
  Name?: string;
  
  @Field({ type: FieldType.INTEGER })  // 整数类型
  Age?: number;
  
  Salary?: number;  // 未映射到表的字段
  
  constructor(name?: string, age?: number) {
    super();
    this.Name = name;
    this.Age = age;
  }
}
```

### 2. TestModel模型

```typescript
@Table
export class TestModel extends Model {
  @Field({ type: FieldType.TEXT })  // 文本类型
  Title?: string;
  
  @Field({ type: FieldType.TEXT })  // 文本类型
  Description?: string;
  
  @Field({ type: FieldType.INTEGER })  // 整数类型
  Status?: number;
  
  @Field({ type: FieldType.TEXT })  // 文本类型（存储时间戳）
  CreatedAt?: string;
  
  constructor(title?: string, description?: string) {
    super();
    this.Title = title;
    this.Description = description;
  }
}
```

### 3. ProcessingHistory模型

```typescript
@Table
export class ProcessingHistory extends Model {
  @Field({ type: FieldType.TEXT, tag: ['notNull'] })  // 非空文本字段
  CustomerName?: string;  // 客户名称
  
  @Field({ type: FieldType.TEXT, tag: ['notNull'] })  // 非空文本字段
  FarmName?: string;      // 农场名称
  
  @Field({ type: FieldType.TEXT, tag: ['notNull'] })  // 非空文本字段
  FruitName?: string;     // 水果名称
  
  @Field({ type: FieldType.TEXT, tag: ['notNull'] })  // 非空文本字段
  Status?: string;        // 状态
  
  @Field({ type: FieldType.TEXT, tag: ['notNull'] })  // 非空文本字段
  StartTime?: string;     // 开始时间
  
  @Field({ type: FieldType.TEXT })  // 文本类型（可空）
  EndTime?: string;       // 结束时间
  
  @Field({ type: FieldType.REAL, tag: ['notNull'] })  // 非空数值字段
  Weight?: number;        // 重量
  
  @Field({ type: FieldType.INTEGER, tag: ['notNull'] })  // 非空整数字段
  Quantity?: number;      // 数量
  
  @Field({ type: FieldType.TEXT })  // 文本类型（可空）
  BatchNo?: string;       // 批次号
  
  @Field({ type: FieldType.TEXT })  // 文本类型（可空）
  Operator?: string;      // 操作员
}
```

## 数据库初始化

### 1. 应用启动时的初始化

在`EntryAbility.ets`中进行全局初始化：

```typescript
// 1. 初始化 IBest-ORM
await IBestORMInit(this.context, {
  name: "database.db",          // 数据库文件名
  securityLevel: relationalStore.SecurityLevel.S1  // 安全级别
});

// 2. 获取数据库管理器实例并初始化表结构
const dbManager = DatabaseManager.getInstance();
await dbManager.initDatabase();
```

### 2. 表结构自动迁移

`DatabaseManager`类的`initDatabase()`方法会自动创建或更新表结构：

```typescript
// 自动迁移表结构（不存在则创建，存在则对齐字段）
dbManager.AutoMigrate(User);
dbManager.AutoMigrate(TestModel);
dbManager.AutoMigrate(ProcessingHistory);
```

## 数据库管理器使用指南

### 1. 获取数据库管理器实例

**重要**：永远不要`new DatabaseManager()`，必须使用单例模式：

```typescript
// 正确用法
const dbManager = DatabaseManager.getInstance();

// 错误用法（永远不要这样做）
// const dbManager = new DatabaseManager(); // ❌ 错误！
```

### 2. User模型操作示例

#### 2.1 添加用户

```typescript
// 方法1：使用便捷函数（推荐）
dbManager.addUser("张三", 25);

// 方法2：使用实体对象
const user = new User("李四", 30);
dbManager.createUser(user);
```

#### 2.2 查询用户

```typescript
// 查询所有用户
const allUsers = dbManager.getAllUsers();

// 根据ID查询
const user = dbManager.getUserById(1);

// 根据年龄查询
const usersOfAge25 = dbManager.getUsersByAge(25);
```

#### 2.3 更新用户

```typescript
// 更新用户信息
dbManager.updateUser(1, "张三-更新", 26);
```

#### 2.4 删除用户

```typescript
// 删除用户
dbManager.deleteUser(1);
```

### 3. ProcessingHistory模型操作示例

#### 3.1 添加历史记录

```typescript
// 添加历史加工记录
dbManager.addProcessingHistory(
  "客户A",              // 客户名称
  "农场B",              // 农场名称
  "苹果",               // 水果名称
  "已完成",             // 状态
  "2024-01-01 10:00:00", // 开始时间
  "2024-01-01 12:00:00", // 结束时间
  100.5,                // 重量
  500                   // 数量
);
```

#### 3.2 查询历史记录

```typescript
// 查询所有历史记录
const allHistory = dbManager.getAllProcessingHistory();

// 根据ID查询
const history = dbManager.getProcessingHistoryById(1);
```

#### 3.3 更新历史记录

```typescript
// 更新状态为"已完成"
dbManager.updateProcessingHistory(1, {
  Status: "已完成",
  EndTime: "2024-01-01 12:30:00"
});
```

#### 3.4 删除历史记录

```typescript
// 删除历史记录
dbManager.deleteProcessingHistory(1);
```

## 事务处理

### 1. 事务的作用

事务可以将多个数据库操作打包成一个原子操作，**要么全部成功，要么全部失败**，确保数据一致性。

### 2. 使用事务示例

```typescript
// 执行事务
const success = await dbManager.executeInTransaction(async () => {
  // 在事务中执行多个操作
  dbManager.addUser("王五", 35);
  dbManager.addProcessingHistory("客户C", "农场D", "橘子", "进行中", new Date().toISOString(), null, 200, 1000);
  
  // 如果代码执行到这里没有抛出异常，事务会自动提交
  // 如果抛出异常，事务会自动回滚
});

// 检查事务是否成功
if (success) {
  console.log("事务执行成功");
} else {
  console.log("事务执行失败，已回滚");
}
```

### 3. 事务的ACID特性

- **原子性（Atomicity）**：事务中的操作要么全部成功，要么全部失败
- **一致性（Consistency）**：事务前后数据保持一致状态
- **隔离性（Isolation）**：多个事务互不干扰
- **持久性（Durability）**：事务提交后数据永久保存

## HTTP API接口

### 1. 接口基础信息

- **服务器地址**：`http://<设备IP>:8080`
- **基础路径**：`/api`
- **数据格式**：JSON
- **认证方式**：暂未实现认证机制

### 2. 通用响应格式

#### 2.1 成功响应

```json
{
  "success": true,
  "data": any,      // 返回的数据，可以是对象、数组或其他类型
  "message": string // 操作成功的提示信息
}
```

#### 2.2 失败响应

```json
{
  "success": false,
  "data": null,
  "message": string // 错误信息
}
```

### 3. 加工数据（Processing History）接口

#### 3.1 获取所有加工数据

- **路径**：`/api/processing`
- **方法**：`GET`
- **功能**：查询所有历史加工数据

#### 3.2 根据ID获取加工数据

- **路径**：`/api/processing/:id`
- **方法**：`GET`
- **功能**：根据ID查询指定的历史加工数据

#### 3.3 创建加工数据

- **路径**：`/api/processing`
- **方法**：`POST`
- **功能**：创建新的历史加工数据
- **请求体**：
  ```json
  {
    "customerName": "客户名称",
    "farmName": "农场名称",
    "fruitName": "水果名称",
    "status": "状态",
    "startTime": "开始时间",
    "endTime": "结束时间",  // 可选
    "weight": 重量,
    "quantity": 数量
  }
  ```

#### 3.4 更新加工数据

- **路径**：`/api/processing/:id`
- **方法**：`PUT`
- **功能**：更新指定ID的历史加工数据
- **请求体**：JSON对象，包含需要更新的字段

#### 3.5 删除加工数据

- **路径**：`/api/processing/:id`
- **方法**：`DELETE`
- **功能**：删除指定ID的历史加工数据

### 4. 用户数据（User）接口

#### 4.1 获取所有用户

- **路径**：`/api/users`
- **方法**：`GET`
- **功能**：查询所有用户数据

#### 4.2 创建用户

- **路径**：`/api/users`
- **方法**：`POST`
- **功能**：创建新用户
- **请求体**：
  ```json
  {
    "name": "用户名",
    "age": 年龄
  }
  ```

### 5. 测试数据（TestModel）接口

#### 5.1 获取所有测试数据

- **路径**：`/api/tests`
- **方法**：`GET`
- **功能**：查询所有测试数据

#### 5.2 创建测试数据

- **路径**：`/api/tests`
- **方法**：`POST`
- **功能**：创建新的测试数据
- **请求体**：
  ```json
  {
    "title": "标题",
    "description": "描述",  // 可选
    "status": 状态码,       // 可选
    "createdAt": "创建时间"  // 可选
  }
  ```

## 常见问题与解决方案

### 1. 字段名不一致问题

**问题**：数据库中字段名可能是小写或小写下划线格式

**解决方案**：`DatabaseManager`中已内置了字段名适配逻辑，可以处理不同格式的字段名。

### 2. 初始化失败

**问题**：数据库初始化失败

**解决方案**：
- 检查`IBestORMInit`是否在`EntryAbility`中正确调用
- 确保传入了正确的Context
- 检查日志中的错误信息

### 3. 事务回滚

**问题**：事务执行失败并回滚

**解决方案**：
- 检查事务中的操作是否合法
- 确保所有非空字段都提供了值
- 查看日志中的错误信息

### 4. API接口错误

**问题**：API接口调用失败

**解决方案**：
- 检查请求URL是否正确
- 确认请求方法（GET/POST/PUT/DELETE）是否正确
- 检查请求参数格式是否符合要求
- 查看响应中的错误信息

## 最佳实践

### 1. 代码层面

1. **始终使用单例**：通过`DatabaseManager.getInstance()`获取实例
2. **使用事务**：涉及多表操作时使用事务保证数据一致性
3. **错误处理**：捕获并处理数据库操作可能抛出的异常
4. **字段验证**：在操作前验证必填字段
5. **资源管理**：数据库连接由框架自动管理，无需手动关闭

### 2. API使用层面

1. **统一响应格式**：前后端使用统一的JSON响应格式
2. **错误处理**：前端正确处理各种错误情况
3. **参数验证**：前端在发送请求前验证数据的有效性
4. **状态管理**：前端维护正确的数据状态

### 3. 调试技巧

1. **查看执行日志**：数据库操作都有详细的日志输出，可以在控制台查看
2. **使用演示功能**：项目中提供了完整的数据库操作演示
3. **API测试工具**：使用Postman或其他工具测试API接口

## 附录：代码示例

### 1. 数据库操作完整示例

```typescript
// 初始化数据库管理器
const dbManager = DatabaseManager.getInstance();

// 添加用户
const userId = await dbManager.addUser("张三", 25);
console.log(`添加用户成功，ID: ${userId}`);

// 查询所有用户
const users = await dbManager.getAllUsers();
console.log(`查询到 ${users.length} 个用户`);

// 更新用户
await dbManager.updateUser(userId, "张三-更新", 26);

// 删除用户
await dbManager.deleteUser(userId);

// 执行事务
const success = await dbManager.executeInTransaction(async () => {
  // 在事务中执行多个操作
  await dbManager.addUser("李四", 30);
  await dbManager.addProcessingHistory("客户X", "农场Y", "草莓", "进行中", new Date().toISOString(), null, 150, 750);
});

if (success) {
  console.log("事务执行成功");
} else {
  console.log("事务执行失败");
}
```

### 2. API调用示例

```javascript
// 获取所有加工数据
fetch('http://localhost:8080/api/processing')
  .then(response => response.json())
  .then(data => {
    if (data.success) {
      console.log('获取成功', data.data);
    } else {
      console.error('获取失败', data.message);
    }
  });

// 创建加工数据
fetch('http://localhost:8080/api/processing', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    customerName: '测试客户',
    farmName: '测试农场',
    fruitName: '测试水果',
    status: '进行中',
    startTime: '2024-01-10 00:00:00',
    weight: 100,
    quantity: 500
  })
})
.then(response => response.json())
.then(data => {
  if (data.success) {
    console.log('创建成功', data.data);
  } else {
    console.error('创建失败', data.message);
  }

- **版本号**：v1.0.0

